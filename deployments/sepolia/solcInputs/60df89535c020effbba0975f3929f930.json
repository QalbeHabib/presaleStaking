{
  "language": "Solidity",
  "sources": {
    "contracts/Sale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// Import our custom contracts\nimport \"./SaleBase.sol\";\nimport \"./StakingManager.sol\";\n\n/**\n * @title PreSale and Staking Contract\n * @notice This contract handles token presale, referral rewards, and staking functionality\n * @dev All tokens (presale, referral, staking) must be sent to the contract before starting\n *\n * Token Allocation:\n * - 30% for presale (30,000,000,000 tokens)\n * - 5% for referral rewards (5,000,000,000 tokens)\n * - 20% for staking rewards (20,000,000,000 tokens)\n *\n * Total: 55% of total supply must be transferred to this contract\n */\ncontract Sale is SaleBase, StakingManager {\n    using SafeMath for uint256;\n    \n    // Override the maxStakingRewards to resolve conflicts between base contracts\n    // Use the SaleBase implementation for maxStakingRewards\n    function maxStakingRewards() public view override(SaleBase, StakingManager) returns (uint256) {\n        return SaleBase.maxStakingRewards();\n    }\n    \n    /**\n     * @dev Constructor sets up the contract parameters\n     * @param _oracle Chainlink oracle for ETH price feed\n     * @param _usdt USDT token address\n     * @param _SaleToken Sale token address\n     * @param _MinTokenTobuy Minimum tokens that can be purchased\n     * @param _totalTokenSupply Total token supply (100,000,000,000)\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) SaleBase(_oracle, _usdt, _SaleToken, _MinTokenTobuy, _totalTokenSupply) \n      StakingManager(_SaleToken, _totalTokenSupply) {\n        // All initialization is done in parent constructors\n    }\n\n    /**\n     * @dev To buy into a presale using USDT with option for immediate staking\n     * @param usdAmount USDT amount to buy tokens\n     * @param referrer Referrer address (optional, use address(0) for no referrer)\n     * @param shouldStake If true, tokens are immediately staked for 1 year with 200% APY\n     */\n    function buyWithUSDT(\n        uint256 usdAmount, \n        address referrer, \n        bool shouldStake\n    ) external\n        checkPresaleId(presaleId)\n        checkSaleState(presaleId, usdtToTokens(presaleId, usdAmount))\n        nonReentrant\n        returns (bool)\n    {\n        require(isTokenPreFunded, \"Contract not pre-funded with tokens\");\n        require(!paused[presaleId], \"Presale paused\");\n        require(presale[presaleId].Active == true, \"Presale is not active yet\");\n        require(presale[presaleId].amountRaised + usdAmount <= presale[presaleId].UsdtHardcap,\n        \"Amount should be less than leftHardcap\");\n\n        // Handle referral if provided and not zero address\n        if (referrer != address(0)) {\n            // Security check to prevent contract-based referrals (potential attack vector)\n            require(!isContract(referrer), \"Referrer cannot be a contract\");\n            recordReferral(referrer);\n        }\n\n        uint256 tokens = usdtToTokens(presaleId, usdAmount);\n        presale[presaleId].Sold += tokens;\n        presale[presaleId].amountRaised += usdAmount;\n\n        if (isExcludeMinToken[msg.sender] == false) {\n            require(tokens >= MinTokenTobuy, \"Less than min amount\");\n        }\n\n        uint256 ourAllowance = USDTInterface.allowance(\n            _msgSender(),\n            address(this)\n        );\n        require(usdAmount <= ourAllowance, \"Make sure to add enough allowance\");\n        (bool success, ) = address(USDTInterface).call(\n            abi.encodeWithSignature(\n                \"transferFrom(address,address,uint256)\",\n                _msgSender(),\n                fundReceiver,\n                usdAmount\n            )\n        );\n        require(success, \"Token payment failed\");\n        \n        // Process referral rewards only if referrer is not zero address\n        if (referrer != address(0)) {\n            processReferralRewards(_msgSender(), tokens);\n        }\n        \n        // Handle tokens based on staking preference\n        if (shouldStake) {\n            // Directly stake tokens since the contract is pre-funded\n            _handleTokenStaking(_msgSender(), tokens);\n        } else {\n            // Record for later claiming\n            if (userClaimData[_msgSender()][presaleId].totalAmount > 0) {\n                userClaimData[_msgSender()][presaleId].totalAmount += tokens;\n            } else {\n                userClaimData[_msgSender()][presaleId] = ClaimData(0, tokens, 0);\n            }\n        }\n        \n        emit TokensBought(\n            _msgSender(),\n            presaleId,\n            address(USDTInterface),\n            tokens,\n            usdAmount,\n            block.timestamp\n        );\n        \n        return true;\n    }\n\n    /**\n     * @dev To buy into a presale using ETH with option for immediate staking\n     * @param referrer Referrer address (optional, use address(0) for no referrer)\n     * @param shouldStake If true, tokens are immediately staked for 1 year with 200% APY\n     */\n    function buyWithEth(\n        address referrer, \n        bool shouldStake\n    ) external\n        payable\n        checkPresaleId(presaleId)\n        checkSaleState(presaleId, ethToTokens(presaleId, msg.value))\n        nonReentrant\n        returns (bool)\n    {\n        require(isTokenPreFunded, \"Contract not pre-funded with tokens\");\n        uint256 usdAmount = (msg.value * getLatestPrice() * USDT_MULTIPLIER) / (ETH_MULTIPLIER * ETH_MULTIPLIER);\n        require(presale[presaleId].amountRaised + usdAmount <= presale[presaleId].UsdtHardcap,\n        \"Amount should be less than leftHardcap\");\n\n        require(!paused[presaleId], \"Presale paused\");\n        require(presale[presaleId].Active == true, \"Presale is not active yet\");\n        \n        // Handle referral if provided and not zero address\n        if (referrer != address(0)) {\n            // Security check to prevent contract-based referrals\n            require(!isContract(referrer), \"Referrer cannot be a contract\");\n            recordReferral(referrer);\n        }\n\n        uint256 tokens = usdtToTokens(presaleId, usdAmount);\n        if (isExcludeMinToken[msg.sender] == false) {\n            require(tokens >= MinTokenTobuy, \"Insufficient amount!\");\n        }\n        presale[presaleId].Sold += tokens;\n        presale[presaleId].amountRaised += usdAmount;\n\n        // Process referral rewards only if referrer is not zero address\n        if (referrer != address(0)) {\n            processReferralRewards(_msgSender(), tokens);\n        }\n\n        // Handle tokens based on staking preference\n        if (shouldStake) {\n            // Directly stake tokens since the contract is pre-funded\n            _handleTokenStaking(_msgSender(), tokens);\n        } else {\n            // Record for later claiming\n            if (userClaimData[_msgSender()][presaleId].totalAmount > 0) {\n                userClaimData[_msgSender()][presaleId].totalAmount += tokens;\n            } else {\n                userClaimData[_msgSender()][presaleId] = ClaimData(\n                    0, // Last claimed at\n                    tokens, // total tokens to be claimed\n                    0 // claimed amount\n                );\n            }\n        }\n\n        sendValue(payable(fundReceiver), msg.value);\n        emit TokensBought(\n            _msgSender(),\n            presaleId,\n            address(0),\n            tokens,\n            msg.value,\n            block.timestamp\n        );\n        \n        return true;\n    }\n    \n    /**\n     * @dev Modified claim function to handle only non-staked tokens\n     * @param _id Presale id\n     */\n    function claimAmount(uint256 _id)\n        public\n        override\n        checkPresaleId(_id)\n        returns (bool)\n    {\n        uint256 amount = claimableAmount(msg.sender, _id);\n        \n        require(amount > 0, \"Zero claim amount\");\n        require(\n            SaleToken != address(0),\n            \"Presale token address not set\"\n        );\n        require(\n            amount <= IERC20(SaleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n\n        require((presale[_id].isEnableClaim == true), \"Claim is not enable\");\n\n        userClaimData[msg.sender][_id].claimAt = block.timestamp;\n        userClaimData[msg.sender][_id].claimedAmount += amount;\n        \n        // Check if the user has set staking intent\n        if (userStakingIntent[msg.sender]) {\n            // Stake all tokens directly\n            _handleTokenStaking(msg.sender, amount);\n            \n            // Reset staking intent after processing\n            userStakingIntent[msg.sender] = false;\n        } else {\n            // Normal token transfer for non-staking users\n            bool success = IERC20(SaleToken).transfer(msg.sender, amount);\n            require(success, \"Token transfer failed\");\n        }\n        \n        emit TokensClaimed(msg.sender, _id, amount, block.timestamp);\n        return true;\n    }\n\n    function WithdrawTokens(address _token, uint256 amount) external override onlyOwner {\n        if (_token == SaleToken) {\n            // Calculate tokens needed for rewards and stakes\n            uint256 reservedTokens = totalReferralRewardsIssued.add(\n                // Staked tokens plus their potential rewards\n                totalStaked.mul(STAKING_APY + 100).div(PERCENT_DENOMINATOR)\n            );\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(\n                contractBalance.sub(amount) >= reservedTokens,\n                \"Cannot withdraw tokens reserved for rewards\"\n            );\n        }\n        \n        bool success = IERC20(_token).transfer(fundReceiver, amount);\n        require(success, \"Token transfer failed\");\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/SaleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface Aggregator {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/**\n * @title Sale Base Contract\n * @notice This contract handles the core presale and referral functionality\n */\ncontract SaleBase is ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n    \n    // Named constants for clarity\n    uint256 public constant TOKEN_DECIMALS = 10**18;\n    uint256 public constant SECONDS_PER_DAY = 86400;\n    uint256 public constant DAYS_PER_YEAR = 365;\n    uint256 public constant PERCENT_DENOMINATOR = 100;\n    \n    uint256 public presaleId;\n    uint256 public USDT_MULTIPLIER;\n    uint256 public ETH_MULTIPLIER;\n    address public fundReceiver;\n\n    // Token allocation constants\n    uint256 public constant PRESALE_ALLOCATION_PERCENT = 30;\n    uint256 public constant REFERRAL_ALLOCATION_PERCENT = 5;\n    uint256 public constant STAKING_ALLOCATION_PERCENT = 20;\n    \n    // Total supply and allocations\n    uint256 public totalTokenSupply;\n    uint256 public presaleTokens;\n    uint256 public maxReferralRewards;\n    uint256 private _maxStakingRewards; // Private state variable instead\n\n    // Referral system constants and variables\n    uint256 public constant MINIMUM_PURCHASE_FOR_REFERRAL = 1000 * TOKEN_DECIMALS; // 1000 tokens minimum to qualify for referral\n    uint256 public referralRewardPercentage = 20; // Default 20% reward (configurable)\n    uint256 public constant MAX_REFERRAL_PERCENTAGE = 20; // Maximum allowed reward percentage\n    uint256 public totalReferralRewardsIssued;\n    uint256 public constant REFERRAL_DENOMINATOR = 100; // For percentage calculations\n\n    // Anti-gaming time lock for referral changes\n    uint256 public referralPercentageChangeTimeLock;\n    uint256 public constant REFERRAL_CHANGE_TIMELOCK = 24 hours;\n\n    struct Presale {\n        uint256 startTime;\n        uint256 endTime;\n        uint256 price;\n        uint256 nextStagePrice;\n        uint256 Sold;\n        uint256 tokensToSell;\n        uint256 UsdtHardcap;\n        uint256 amountRaised;\n        bool Active;\n        bool isEnableClaim;\n    }\n\n    struct ClaimData {\n        uint256 claimAt;\n        uint256 totalAmount;\n        uint256 claimedAmount;\n    }\n\n    // Referral data structure\n    struct ReferralData {\n        address referrer;\n        uint256 totalReferralRewards;\n        uint256 claimedReferralRewards;\n        bool hasReferred; // Flag to check if user has made at least one referral\n        uint256 referralCount; // Track number of successful referrals\n    }\n\n    IERC20Metadata public USDTInterface;\n    Aggregator internal aggregatorInterface;\n    // https://docs.chain.link/docs/ethereum-addresses/ => (ETH / USD)\n\n    mapping(uint256 => bool) public paused;\n    mapping(uint256 => Presale) public presale;\n    mapping(address => mapping(uint256 => ClaimData)) public userClaimData;\n    mapping(address => bool) public isExcludeMinToken;\n    \n    // Referral system mappings\n    mapping(address => ReferralData) public referralData;\n    mapping(address => bool) public hasQualifiedPurchase; // Track if user has purchased enough to qualify as referrer\n    mapping(address => bool) public hasUsedReferral; // Prevent using multiple referrals\n\n    uint256 public MinTokenTobuy;\n    address public SaleToken;\n\n    // Mapping to track users who want to stake ALL their tokens upon claim\n    mapping(address => bool) public userStakingIntent;\n\n    // Track if the contract has been pre-funded\n    bool public isTokenPreFunded = false;\n\n    event TokensPreFunded(address indexed token, uint256 amount, uint256 timestamp);\n    \n    event PresaleCreated(\n        uint256 indexed _id,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime\n    );\n\n    event PresaleUpdated(\n        bytes32 indexed key,\n        uint256 prevValue,\n        uint256 newValue,\n        uint256 timestamp\n    );\n\n    event TokensBought(\n        address indexed user,\n        uint256 indexed id,\n        address indexed purchaseToken,\n        uint256 tokensBought,\n        uint256 amountPaid,\n        uint256 timestamp\n    );\n\n    event TokensClaimed(\n        address indexed user,\n        uint256 indexed id,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event PresaleTokenAddressUpdated(\n        address indexed prevValue,\n        address indexed newValue,\n        uint256 timestamp\n    );\n\n    event PresalePaused(uint256 indexed id, uint256 timestamp);\n    event PresaleUnpaused(uint256 indexed id, uint256 timestamp);\n    \n    // Referral Events\n    event ReferralRecorded(\n        address indexed referrer, \n        address indexed referee, \n        uint256 timestamp\n    );\n    \n    event ReferralRewardsClaimed(\n        address indexed user, \n        uint256 amount, \n        uint256 timestamp\n    );\n    \n    event ReferralPercentageUpdated(\n        uint256 previousPercentage, \n        uint256 newPercentage, \n        uint256 timestamp\n    );\n    \n    event ReferralRewardsAdded(\n        address indexed referrer, \n        address indexed referee, \n        uint256 referrerReward, \n        uint256 refereeReward, \n        uint256 timestamp\n    );\n\n    /**\n     * @dev Constructor sets up the contract parameters\n     * @param _oracle Chainlink oracle for ETH price feed\n     * @param _usdt USDT token address\n     * @param _SaleToken Sale token address\n     * @param _MinTokenTobuy Minimum tokens that can be purchased\n     * @param _totalTokenSupply Total token supply (100,000,000,000)\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) Ownable() {\n        require(_oracle != address(0), \"Oracle address cannot be zero\");\n        require(_usdt != address(0), \"USDT address cannot be zero\");\n        require(_SaleToken != address(0), \"Sale token address cannot be zero\");\n        require(_MinTokenTobuy > 0, \"Minimum token to buy must be greater than zero\");\n        require(_totalTokenSupply > 0, \"Total supply must be greater than zero\");\n        \n        aggregatorInterface = Aggregator(_oracle);\n        SaleToken = _SaleToken;\n        MinTokenTobuy = _MinTokenTobuy;\n        USDTInterface = IERC20Metadata(_usdt);\n        ETH_MULTIPLIER = (10**18);\n        USDT_MULTIPLIER =(10**6);\n        fundReceiver = msg.sender;\n        \n        // Store total supply\n        totalTokenSupply = _totalTokenSupply;\n        \n        // Calculate allocations\n        presaleTokens = _totalTokenSupply.mul(PRESALE_ALLOCATION_PERCENT).div(PERCENT_DENOMINATOR); // 30% for presale\n        maxReferralRewards = _totalTokenSupply.mul(REFERRAL_ALLOCATION_PERCENT).div(PERCENT_DENOMINATOR); // 5% for referrals\n        _maxStakingRewards = _totalTokenSupply.mul(STAKING_ALLOCATION_PERCENT).div(PERCENT_DENOMINATOR); // 20% for staking rewards\n    }\n    \n    /**\n     * @dev Pre-fund the contract with tokens for presale, referrals, and staking\n     * @notice Before calling this function:\n     * 1. Deploy the token contract\n     * 2. Transfer 55% of total supply to this contract address\n     * 3. Call this function to verify and activate the pre-funding\n     *\n     * This marks the contract as ready for presale with tokens available for:\n     * - Direct distribution for non-staking purchases\n     * - Immediate staking during purchase (no need to claim first)\n     * - Referral reward distribution\n     */\n    function preFundContract() external onlyOwner {\n        require(!isTokenPreFunded, \"Contract already pre-funded\");\n        require(SaleToken != address(0), \"Sale token not set\");\n        \n        // Calculate total tokens needed\n        uint256 totalRequired = presaleTokens.add(maxReferralRewards).add(_maxStakingRewards);\n        \n        // Check contract balance\n        uint256 contractBalance = IERC20(SaleToken).balanceOf(address(this));\n        require(contractBalance >= totalRequired, \"Insufficient token balance\");\n        \n        // Set pre-funded flag\n        isTokenPreFunded = true;\n        \n        emit TokensPreFunded(SaleToken, contractBalance, block.timestamp);\n    }\n\n    /**\n     * @dev Update the maximum referral rewards (5% of total supply)\n     * @param _totalSupply The total token supply to calculate 5% from\n     */\n    function updateMaxReferralRewards(uint256 _totalSupply) external onlyOwner {\n        require(_totalSupply > 0, \"Invalid total supply\");\n        maxReferralRewards = _totalSupply.mul(REFERRAL_ALLOCATION_PERCENT).div(PERCENT_DENOMINATOR);\n    }\n\n    /**\n     * @dev Change referral reward percentage with timelock protection\n     * @param _percentage New percentage (1-20)\n     */\n    function updateReferralRewardPercentage(uint256 _percentage) external onlyOwner {\n        require(_percentage > 0 && _percentage <= MAX_REFERRAL_PERCENTAGE, \"Invalid percentage\");\n        require(block.timestamp >= referralPercentageChangeTimeLock, \"Timelock active\");\n        \n        // Set new timelock for future changes\n        referralPercentageChangeTimeLock = block.timestamp.add(REFERRAL_CHANGE_TIMELOCK);\n        \n        uint256 oldPercentage = referralRewardPercentage;\n        referralRewardPercentage = _percentage;\n        \n        emit ReferralPercentageUpdated(oldPercentage, _percentage, block.timestamp);\n    }\n\n    /**\n     * @dev Records a valid referral relationship\n     * @param _referrer Address of the referrer\n     */\n    function recordReferral(address _referrer) internal {\n        // Security checks\n        require(_referrer != address(0), \"Invalid referrer\");\n        require(_referrer != msg.sender, \"Cannot refer yourself\");\n        require(!hasUsedReferral[msg.sender], \"Already used a referral\");\n        require(hasQualifiedPurchase[_referrer], \"Referrer has not qualified\");\n        \n        // Record the referral relationship\n        referralData[msg.sender].referrer = _referrer;\n        hasUsedReferral[msg.sender] = true;\n        \n        // Update referrer stats\n        referralData[_referrer].hasReferred = true;\n        referralData[_referrer].referralCount++;\n        \n        emit ReferralRecorded(_referrer, msg.sender, block.timestamp);\n    }\n\n    /**\n     * @dev Process referral rewards after a successful purchase\n     * @param _user Address of the user who made a purchase\n     * @param _tokenAmount Amount of tokens purchased\n     */\n    function processReferralRewards(address _user, uint256 _tokenAmount) internal {\n        // Check if purchase meets minimum for referral qualification\n        if (_tokenAmount >= MINIMUM_PURCHASE_FOR_REFERRAL) {\n            hasQualifiedPurchase[_user] = true;\n        }\n        \n        // If user has a referrer, calculate and assign rewards\n        address referrer = referralData[_user].referrer;\n        if (referrer != address(0) && _tokenAmount >= MINIMUM_PURCHASE_FOR_REFERRAL) {\n            // Calculate rewards (both get the same percentage)\n            uint256 referrerReward = _tokenAmount.mul(referralRewardPercentage).div(REFERRAL_DENOMINATOR);\n            uint256 refereeReward = referrerReward; // Same reward for both parties\n            \n            // Check against the max referral rewards cap\n            uint256 totalNewRewards = referrerReward.add(refereeReward);\n            if (totalReferralRewardsIssued.add(totalNewRewards) <= maxReferralRewards) {\n                // Update referrer's rewards\n                referralData[referrer].totalReferralRewards = \n                    referralData[referrer].totalReferralRewards.add(referrerReward);\n                \n                // Update referee's rewards\n                referralData[_user].totalReferralRewards = \n                    referralData[_user].totalReferralRewards.add(refereeReward);\n                \n                // Update total rewards issued\n                totalReferralRewardsIssued = totalReferralRewardsIssued.add(totalNewRewards);\n                \n                emit ReferralRewardsAdded(\n                    referrer, \n                    _user, \n                    referrerReward, \n                    refereeReward, \n                    block.timestamp\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Get claimable referral rewards for a user\n     * @param _user Address of the user\n     */\n    function getClaimableReferralRewards(address _user) public view returns (uint256) {\n        ReferralData memory data = referralData[_user];\n        return data.totalReferralRewards.sub(data.claimedReferralRewards);\n    }\n\n    /**\n     * @dev Claim referral rewards\n     */\n    function claimReferralRewards() external nonReentrant returns (bool) {\n        uint256 amount = getClaimableReferralRewards(msg.sender);\n        require(amount > 0, \"No rewards to claim\");\n        \n        // Verify there are enough tokens in the contract\n        require(\n            amount <= IERC20(SaleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n        \n        // Update claimed amount\n        referralData[msg.sender].claimedReferralRewards = \n            referralData[msg.sender].claimedReferralRewards.add(amount);\n        \n        // Transfer tokens\n        bool success = IERC20(SaleToken).transfer(msg.sender, amount);\n        require(success, \"Token transfer failed\");\n        \n        emit ReferralRewardsClaimed(msg.sender, amount, block.timestamp);\n        return true;\n    }\n\n    // Utility function to check if an address is a contract\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    function ChangeTokenToSell(address _token) public onlyOwner {\n        SaleToken = _token;\n    }\n\n    function EditMinTokenToBuy(uint256 _amount) public onlyOwner {\n        MinTokenTobuy = _amount;\n    }\n\n    function createPresale(uint256 _price,uint256 _nextStagePrice, uint256 _tokensToSell, uint256 _UsdtHardcap)\n        external\n        onlyOwner\n    {\n        require(_price > 0, \"Zero price\");\n        require(_tokensToSell > 0, \"Zero tokens to sell\");\n        require(presale[presaleId].Active == false, \"Previous Sale is Active\");\n\n        presaleId++;\n\n        presale[presaleId] = Presale(\n            0,\n            0,\n            _price,\n            _nextStagePrice,\n            0,\n            _tokensToSell,\n            _UsdtHardcap,\n            0,\n            false,\n            false\n        );\n\n        emit PresaleCreated(presaleId, _tokensToSell, 0, 0);\n    }\n\n    function startPresale() public onlyOwner {\n        presale[presaleId].startTime = block.timestamp;\n        presale[presaleId].Active = true;\n    }\n\n    function endPresale() public onlyOwner {\n        require(\n            presale[presaleId].Active = true,\n            \"This presale is already Inactive\"\n        );\n        presale[presaleId].endTime = block.timestamp;\n        presale[presaleId].Active = false;\n    }\n\n    // @dev enabel Claim amount\n    function enableClaim(uint256 _id, bool _status)\n        public\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        presale[_id].isEnableClaim = _status;\n    }\n\n    function updatePresale(\n        uint256 _id,\n        uint256 _price,\n        uint256 _nextStagePrice,\n        uint256 _tokensToSell,\n        uint256 _Hardcap\n    ) external checkPresaleId(_id) onlyOwner {\n        require(_price > 0, \"Zero price\");\n        require(_tokensToSell > 0, \"Zero tokens to sell\");\n        presale[_id].price = _price;\n        presale[_id].nextStagePrice = _nextStagePrice;\n        presale[_id].tokensToSell = _tokensToSell;\n        presale[_id].UsdtHardcap =_Hardcap;\n    }\n\n    /**\n     * @dev To update the fund receiving wallet\n     * @param _wallet address of wallet to update\n\n     */\n    function changeFundWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Invalid parameters\");\n        fundReceiver = _wallet;\n    }\n\n    /**\n     * @dev To update the USDT Token address\n     * @param _newAddress Sale token address\n     */\n    function changeUSDTToken(address _newAddress) external onlyOwner {\n        require(_newAddress != address(0), \"Zero token address\");\n        USDTInterface = IERC20Metadata(_newAddress);\n    }\n\n    /**\n     * @dev To pause the presale\n     * @param _id Presale id to update\n     */\n    function pausePresale(uint256 _id) external checkPresaleId(_id) onlyOwner {\n        require(!paused[_id], \"Already paused\");\n        paused[_id] = true;\n        emit PresalePaused(_id, block.timestamp);\n    }\n\n    /**\n     * @dev To unpause the presale\n     * @param _id Presale id to update\n     */\n    function unPausePresale(uint256 _id)\n        external\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        require(paused[_id], \"Not paused\");\n        paused[_id] = false;\n        emit PresaleUnpaused(_id, block.timestamp);\n    }\n\n    /**\n     * @dev To get latest ethereum price in 10**18 format\n     */\n    function getLatestPrice() public view returns (uint256) {\n        (, int256 price, , , ) = aggregatorInterface.latestRoundData();\n        price = (price * (10**10));\n        return uint256(price);\n    }\n\n    modifier checkPresaleId(uint256 _id) {\n        require(_id > 0 && _id <= presaleId, \"Invalid presale id\");\n        _;\n    }\n\n    modifier checkSaleState(uint256 _id, uint256 amount) {\n        require(\n            block.timestamp >= presale[_id].startTime &&\n                presale[_id].Active == true,\n            \"Invalid time for buying\"\n        );\n        require(\n            amount > 0 && amount <= presale[_id].tokensToSell-presale[_id].Sold,\n            \"Invalid sale amount\"\n        );\n        _;\n    }\n\n    function ExcludeAccouctFromMinBuy(address _user, bool _status)\n        external\n        onlyOwner\n    {\n        isExcludeMinToken[_user] = _status;\n    }\n\n    /**\n     * @dev Helper funtion to get ETH price for given amount\n     * @param _id Presale id\n     * @param amount No of tokens to buy\n     */\n    function ethBuyHelper(uint256 _id, uint256 amount)\n        external\n        view\n        checkPresaleId(_id)\n        returns (uint256 ethAmount)\n    {\n        uint256 usdPrice = (amount * presale[_id].price);\n        ethAmount = (usdPrice * ETH_MULTIPLIER) / (getLatestPrice() * 10**IERC20Metadata(SaleToken).decimals());\n    }\n\n    /**\n     * @dev Helper funtion to get USDT price for given amount\n     * @param _id Presale id\n     * @param amount No of tokens to buy\n     */\n    function usdtBuyHelper(uint256 _id, uint256 amount)\n        external\n        view\n        checkPresaleId(_id)\n        returns (uint256 usdPrice)\n    {\n        usdPrice = (amount * presale[_id].price) / 10**IERC20Metadata(SaleToken).decimals();\n    }\n\n    /**\n     * @dev Helper funtion to get tokens for eth amount\n     * @param _id Presale id\n     * @param amount No of eth\n     */\n    function ethToTokens(uint256 _id, uint256 amount)\n        public\n        view\n        returns (uint256 _tokens)\n    {\n        uint256 usdAmount = amount * getLatestPrice() * USDT_MULTIPLIER / (ETH_MULTIPLIER * ETH_MULTIPLIER);\n        _tokens = usdtToTokens(_id, usdAmount);\n    }\n\n    /**\n     * @dev Helper funtion to get tokens for given usdt amount\n     * @param _id Presale id\n     * @param amount No of usdt\n     */\n    function usdtToTokens(uint256 _id, uint256 amount)\n        public\n        view\n        checkPresaleId(_id)\n        returns (uint256 _tokens)\n    {\n        _tokens = (amount * presale[_id].price) / USDT_MULTIPLIER;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Low balance\");\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"ETH Payment failed\");\n    }\n\n    function unlockToken(uint256 _id)\n        public\n        view\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        require(\n            block.timestamp >= presale[_id].endTime,\n            \"You can only unlock on finalize\"\n        );\n    }\n\n    /**\n     * @dev Helper funtion to get claimable tokens for a given presale.\n     * @param user User address\n     * @param _id Presale id\n     */\n    function claimableAmount(address user, uint256 _id)\n        public\n        view\n        checkPresaleId(_id)\n        returns (uint256)\n    {\n        ClaimData memory _user = userClaimData[user][_id];\n\n        require(_user.totalAmount > 0, \"Nothing to claim\");\n        uint256 amount = _user.totalAmount - _user.claimedAmount;\n        require(amount > 0, \"Already claimed\");\n        return amount;\n    }\n\n    /**\n     * @dev To claim tokens from a multiple presale\n     * @param _id Presale id\n     */\n    function claimMultiple(uint256[] calldata _id) external returns (bool) {\n        require(_id.length > 0, \"Zero ID length\");\n        for (uint256 i; i < _id.length; i++) {\n            require(claimAmount(_id[i]), \"Claim failed\");\n        }\n        return true;\n    }\n    \n    /**\n     * @dev Modified claim function to handle only non-staked tokens\n     * @param _id Presale id\n     */\n    function claimAmount(uint256 _id)\n        public \n        virtual\n        checkPresaleId(_id)\n        returns (bool)\n    {\n        uint256 amount = claimableAmount(msg.sender, _id);\n        \n        require(amount > 0, \"Zero claim amount\");\n        require(\n            SaleToken != address(0),\n            \"Presale token address not set\"\n        );\n        require(\n            amount <= IERC20(SaleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n\n        require((presale[_id].isEnableClaim == true), \"Claim is not enable\");\n\n        userClaimData[msg.sender][_id].claimAt = block.timestamp;\n        userClaimData[msg.sender][_id].claimedAmount += amount;\n        \n        bool success = IERC20(SaleToken).transfer(msg.sender, amount);\n        require(success, \"Token transfer failed\");\n        \n        emit TokensClaimed(msg.sender, _id, amount, block.timestamp);\n        return true;\n    }\n    \n    // Add functions to get user referral status for the frontend\n    function getUserReferralInfo(address _user) external view returns (\n        address referrer,\n        uint256 totalRewards,\n        uint256 claimedRewards,\n        uint256 pendingRewards,\n        bool isQualifiedReferrer,\n        uint256 referralCount\n    ) {\n        ReferralData memory data = referralData[_user];\n        return (\n            data.referrer,\n            data.totalReferralRewards,\n            data.claimedReferralRewards,\n            data.totalReferralRewards.sub(data.claimedReferralRewards),\n            hasQualifiedPurchase[_user],\n            data.referralCount\n        );\n    }\n\n    // Get referral program stats\n    function getReferralProgramStats() external view returns (\n        uint256 currentPercentage,\n        uint256 totalRewardsIssued,\n        uint256 maxRewards,\n        uint256 remainingRewards,\n        uint256 nextPercentageChangeAllowed\n    ) {\n        return (\n            referralRewardPercentage,\n            totalReferralRewardsIssued,\n            maxReferralRewards,\n            maxReferralRewards.sub(totalReferralRewardsIssued),\n            referralPercentageChangeTimeLock\n        );\n    }\n\n    // Check if a user has a valid referral link to share\n    function canReferOthers(address _user) external view returns (bool) {\n        return hasQualifiedPurchase[_user];\n    }\n\n    function WithdrawTokens(address _token, uint256 amount) external virtual onlyOwner {\n        if (_token == SaleToken) {\n            // Calculate tokens needed for rewards\n            uint256 reservedTokens = totalReferralRewardsIssued;\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(\n                contractBalance.sub(amount) >= reservedTokens,\n                \"Cannot withdraw tokens reserved for rewards\"\n            );\n        }\n        \n        IERC20(_token).transfer(fundReceiver, amount);\n    }\n\n    function WithdrawContractFunds(uint256 amount) external onlyOwner {\n        sendValue(payable(fundReceiver), amount);\n    }\n\n    /**\n     * Accessor function for maxStakingRewards\n     */\n    function maxStakingRewards() public view virtual returns (uint256) {\n        return _maxStakingRewards;\n    }\n} "
    },
    "contracts/StakingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title Staking Manager Contract\n * @notice This contract handles token staking functionality\n */\ncontract StakingManager is ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n    \n    // Keep some constants to maintain internal functionality\n    uint256 internal constant TOKEN_DECIMALS_INT = 10**18;\n    uint256 internal constant PERCENT_DENOMINATOR_INT = 100;\n    \n    // Staking system constants and variables\n    uint256 public constant STAKING_LOCK_PERIOD = 365 days; // 365 days\n    uint256 public constant STAKING_APY = 200; // 200% APY\n    uint256 public totalStaked;\n    uint256 public stakingCap; // Cap at 6,666,666,667 tokens\n    bool public stakingActive;\n    uint256 public totalStakingRewardsIssued;\n    \n    // Maximum staking rewards allocation\n    uint256 private _maxStakingRewards; // Changed to private to avoid duplicate variable with SaleBase\n    \n    // Staking data structure\n    struct StakeInfo {\n        uint256 stakedAmount;\n        uint256 stakingTimestamp;\n        uint256 unlockTimestamp;\n        bool hasWithdrawn;\n    }\n    \n    // Staking system mappings\n    mapping(address => StakeInfo) public userStakes;\n\n    // Token address\n    address public immutable saleToken;\n    \n    // New Staking Events\n    event TokensStaked(\n        address indexed user, \n        uint256 amount, \n        uint256 stakingTime, \n        uint256 unlockTime\n    );\n\n    event StakeWithdrawn(\n        address indexed user, \n        uint256 stakedAmount, \n        uint256 rewardAmount, \n        uint256 timestamp\n    );\n\n    event StakingStatusChanged(\n        bool isActive,\n        uint256 timestamp\n    );\n    \n    event StakingCapUpdated(\n        uint256 previousCap,\n        uint256 newCap,\n        uint256 timestamp\n    );\n    \n    /**\n     * @dev Constructor sets up staking parameters\n     * @param _saleToken Token address used for staking\n     * @param _totalTokenSupply Total token supply for calculating staking allocation\n     */\n    constructor(\n        address _saleToken,\n        uint256 _totalTokenSupply\n    ) {\n        require(_saleToken != address(0), \"Sale token address cannot be zero\");\n        require(_totalTokenSupply > 0, \"Total supply must be greater than zero\");\n        \n        saleToken = _saleToken;\n        \n        // Initialize staking parameters\n        stakingCap = 6666666667 * TOKEN_DECIMALS_INT; // 6,666,666,667 tokens\n        stakingActive = true; // Staking is active by default\n        \n        // Calculate maximum staking rewards (20% of total supply)\n        _maxStakingRewards = _totalTokenSupply.mul(20).div(PERCENT_DENOMINATOR_INT);\n    }\n    \n    /**\n     * Provide an accessor for maxStakingRewards\n     */\n    function maxStakingRewards() public view virtual returns (uint256) {\n        return _maxStakingRewards;\n    }\n    \n    /**\n     * @dev Initialize staking parameters\n     * @param _totalSupply Total token supply to calculate 20% for staking rewards\n     */\n    function initializeStaking(uint256 _totalSupply) external onlyOwner {\n        require(_totalSupply > 0, \"Invalid total supply\");\n        _maxStakingRewards = _totalSupply.mul(20).div(PERCENT_DENOMINATOR_INT); // 20% of total supply\n        stakingActive = true;\n        emit StakingStatusChanged(true, block.timestamp);\n    }\n\n    /**\n     * @dev Toggle staking status (active/inactive)\n     * @param _status New staking status\n     */\n    function setStakingStatus(bool _status) external onlyOwner {\n        stakingActive = _status;\n        emit StakingStatusChanged(_status, block.timestamp);\n    }\n\n    /**\n     * @dev Helper function that handles token staking directly during purchase\n     * @param _user Address of the user\n     * @param _amount Amount of tokens to stake\n     * @notice This function is called automatically during purchase if staking is selected\n     * @notice Tokens are locked for 365 days with 200% APY\n     */\n    function _handleTokenStaking(address _user, uint256 _amount) internal {\n        // Ensure staking is active\n        require(stakingActive, \"Staking is not active\");\n        require(_amount > 0, \"Cannot stake zero amount\");\n        require(\n            totalStaked.add(_amount) <= stakingCap,\n            \"Staking cap would be exceeded\"\n        );\n        \n        // Calculate potential rewards to verify we stay within the rewards limit\n        uint256 potentialReward = _amount.mul(STAKING_APY).div(PERCENT_DENOMINATOR_INT);\n        require(\n            totalStakingRewardsIssued.add(potentialReward) <= maxStakingRewards(),\n            \"Not enough tokens in the staking reward pool\"\n        );\n        \n        // Update global state for staking\n        totalStaked = totalStaked.add(_amount);\n        totalStakingRewardsIssued = totalStakingRewardsIssued.add(potentialReward);\n        \n        // Auto-disable staking if cap is reached\n        if (totalStaked >= stakingCap) {\n            stakingActive = false;\n            emit StakingStatusChanged(false, block.timestamp);\n        }\n        \n        // Update user stake\n        StakeInfo storage userStake = userStakes[_user];\n        \n        // If user already has a stake, handle appropriately\n        if (userStake.stakedAmount > 0 && !userStake.hasWithdrawn) {\n            // If existing stake is still locked, cannot add to it\n            if (block.timestamp < userStake.unlockTimestamp) {\n                revert(\"Cannot stake when you have a locked stake\");\n            } else {\n                // Existing stake is unlocked, withdraw it first\n                uint256 stakedAmount = userStake.stakedAmount;\n                uint256 reward = stakedAmount.mul(STAKING_APY).div(PERCENT_DENOMINATOR_INT);\n                \n                // Mark as withdrawn to prevent double-dipping\n                userStake.hasWithdrawn = true;\n                \n                // Transfer rewards and original stake back\n                bool transferSuccess = IERC20(saleToken).transfer(_user, stakedAmount.add(reward));\n                require(transferSuccess, \"Stake withdrawal failed\");\n                \n                emit StakeWithdrawn(_user, stakedAmount, reward, block.timestamp);\n            }\n        }\n        \n        // Create a new stake\n        userStake.stakedAmount = _amount;\n        userStake.stakingTimestamp = block.timestamp;\n        userStake.unlockTimestamp = block.timestamp.add(STAKING_LOCK_PERIOD);\n        userStake.hasWithdrawn = false;\n        \n        emit TokensStaked(_user, _amount, block.timestamp, userStake.unlockTimestamp);\n    }\n\n    /**\n     * @dev Stake tokens with 1-year lock and 200% APY\n     * @param _amount Amount of tokens to stake\n     */\n    function stakeTokens(uint256 _amount) external nonReentrant {\n        require(stakingActive, \"Staking is not active\");\n        require(_amount > 0, \"Cannot stake zero amount\");\n        require(\n            totalStaked.add(_amount) <= stakingCap,\n            \"Staking cap would be exceeded\"\n        );\n        \n        // Calculate potential rewards to verify we stay within the rewards limit\n        uint256 potentialReward = _amount.mul(STAKING_APY).div(PERCENT_DENOMINATOR_INT);\n        require(\n            totalStakingRewardsIssued.add(potentialReward) <= maxStakingRewards(),\n            \"Not enough tokens in the staking reward pool\"\n        );\n        \n        // Update global state\n        totalStaked = totalStaked.add(_amount);\n        totalStakingRewardsIssued = totalStakingRewardsIssued.add(potentialReward);\n        \n        // Auto-disable staking if cap is reached\n        if (totalStaked >= stakingCap) {\n            stakingActive = false;\n            emit StakingStatusChanged(false, block.timestamp);\n        }\n        \n        // Update user stake\n        StakeInfo storage userStake = userStakes[msg.sender];\n        \n        // If user already has a stake, we need special handling\n        if (userStake.stakedAmount > 0 && !userStake.hasWithdrawn) {\n            require(\n                block.timestamp >= userStake.unlockTimestamp,\n                \"Cannot add to existing stake while locked\"\n            );\n            \n            // Withdraw previous stake first (internally)\n            uint256 stakedAmount = userStake.stakedAmount;\n            uint256 reward = stakedAmount.mul(STAKING_APY).div(PERCENT_DENOMINATOR_INT);\n            \n            // Mark as withdrawn to prevent double-dipping\n            userStake.hasWithdrawn = true;\n            \n            // Transfer rewards and original stake back\n            bool transferSuccess = IERC20(saleToken).transfer(msg.sender, stakedAmount.add(reward));\n            require(transferSuccess, \"Token transfer failed\");\n            \n            // Create a new stake\n            userStake.stakedAmount = _amount;\n            userStake.stakingTimestamp = block.timestamp;\n            userStake.unlockTimestamp = block.timestamp.add(STAKING_LOCK_PERIOD);\n            userStake.hasWithdrawn = false;\n        } else {\n            // First time stake or previous stake was withdrawn\n            userStake.stakedAmount = _amount;\n            userStake.stakingTimestamp = block.timestamp;\n            userStake.unlockTimestamp = block.timestamp.add(STAKING_LOCK_PERIOD);\n            userStake.hasWithdrawn = false;\n        }\n        \n        // Transfer tokens from user to contract (SafeERC20 pattern)\n        uint256 balanceBefore = IERC20(saleToken).balanceOf(address(this));\n        bool transferFromSuccess = IERC20(saleToken).transferFrom(msg.sender, address(this), _amount);\n        require(transferFromSuccess, \"Token transfer failed\");\n        \n        // Verify tokens were actually received (protection against fee-on-transfer tokens)\n        uint256 balanceAfter = IERC20(saleToken).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore.add(_amount), \"Incorrect amount of tokens received\");\n        \n        emit TokensStaked(msg.sender, _amount, block.timestamp, userStake.unlockTimestamp);\n    }\n    \n    /**\n     * @dev Withdraw staked tokens and rewards after lock period\n     */\n    function withdrawStake() external nonReentrant {\n        StakeInfo storage userStake = userStakes[msg.sender];\n        \n        require(userStake.stakedAmount > 0, \"No stake found\");\n        require(!userStake.hasWithdrawn, \"Already withdrawn\");\n        require(\n            block.timestamp >= userStake.unlockTimestamp,\n            \"Stake is still locked\"\n        );\n        \n        uint256 stakedAmount = userStake.stakedAmount;\n        uint256 reward = stakedAmount.mul(STAKING_APY).div(PERCENT_DENOMINATOR_INT);\n        uint256 totalAmount = stakedAmount.add(reward);\n        \n        // Mark as withdrawn to prevent double-dipping\n        userStake.hasWithdrawn = true;\n        \n        // Update global state\n        totalStaked = totalStaked.sub(stakedAmount);\n        \n        // Verify there are enough tokens in the contract\n        require(\n            totalAmount <= IERC20(saleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n        \n        // Transfer rewards and original stake\n        bool withdrawSuccess = IERC20(saleToken).transfer(msg.sender, totalAmount);\n        require(withdrawSuccess, \"Token transfer failed\");\n        \n        emit StakeWithdrawn(msg.sender, stakedAmount, reward, block.timestamp);\n    }\n    \n    /**\n     * @dev Get user staking information\n     * @param _user Address of the user\n     */\n    function getUserStakingInfo(address _user) external view returns (\n        uint256 stakedAmount,\n        uint256 stakingTime,\n        uint256 unlockTime,\n        bool isLocked,\n        bool hasWithdrawn,\n        uint256 potentialReward,\n        uint256 totalClaimable\n    ) {\n        StakeInfo storage stake = userStakes[_user];\n        bool locked = block.timestamp < stake.unlockTimestamp;\n        uint256 reward = stake.stakedAmount.mul(STAKING_APY).div(PERCENT_DENOMINATOR_INT);\n        \n        return (\n            stake.stakedAmount,\n            stake.stakingTimestamp,\n            stake.unlockTimestamp,\n            locked,\n            stake.hasWithdrawn,\n            reward,\n            stake.hasWithdrawn ? 0 : stake.stakedAmount.add(reward)\n        );\n    }\n    \n    /**\n     * @dev Get staking program statistics\n     */\n    function getStakingStats() external view returns (\n        uint256 _totalStaked,\n        uint256 _stakingCap,\n        uint256 _stakingAPY,\n        bool _isActive,\n        uint256 _maxRewards,\n        uint256 _totalRewardsCommitted,\n        uint256 _remainingRewards\n    ) {\n        return (\n            totalStaked,\n            stakingCap,\n            STAKING_APY,\n            stakingActive,\n            maxStakingRewards(),\n            totalStakingRewardsIssued,\n            maxStakingRewards().sub(totalStakingRewardsIssued)\n        );\n    }\n\n    /**\n     * @dev Quick check if staking is available and capacity info\n     * @return _canStake True if staking is active and cap not reached\n     * @return _remainingCapacity Remaining capacity for staking\n     * @return _percentFilled Percentage of staking capacity filled (0-100)\n     */\n    function getStakingAvailability() external view returns (\n        bool _canStake,\n        uint256 _remainingCapacity,\n        uint256 _percentFilled\n    ) {\n        bool canStake = stakingActive && totalStaked < stakingCap;\n        uint256 remainingCapacity = stakingCap > totalStaked ? stakingCap.sub(totalStaked) : 0;\n        uint256 percentFilled = totalStaked.mul(100).div(stakingCap);\n        \n        return (canStake, remainingCapacity, percentFilled);\n    }\n    \n    /**\n     * @dev Update staking cap\n     * @param _newCap New staking cap\n     */\n    function updateStakingCap(uint256 _newCap) external onlyOwner {\n        require(_newCap >= totalStaked, \"New cap must be >= total staked\");\n        \n        uint256 oldCap = stakingCap;\n        stakingCap = _newCap;\n        \n        emit StakingCapUpdated(oldCap, _newCap, block.timestamp);\n    }\n    \n    /**\n     * @dev Safe withdrawal function for accumulated tokens\n     * @param _token Token address\n     * @param _amount Amount to withdraw\n     * @param _recipient Recipient address\n     */\n    function safeWithdraw(address _token, uint256 _amount, address _recipient) external onlyOwner {\n        require(_recipient != address(0), \"Cannot withdraw to zero address\");\n        \n        if (_token == saleToken) {\n            // Calculate tokens needed for staking rewards\n            uint256 reservedForStaking = totalStaked.mul(STAKING_APY + 100).div(PERCENT_DENOMINATOR_INT);\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(\n                contractBalance.sub(_amount) >= reservedForStaking,\n                \"Cannot withdraw tokens reserved for staking rewards\"\n            );\n        }\n        \n        bool withdrawSuccess = IERC20(_token).transfer(_recipient, _amount);\n        require(withdrawSuccess, \"Token transfer failed\");\n    }\n} "
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}