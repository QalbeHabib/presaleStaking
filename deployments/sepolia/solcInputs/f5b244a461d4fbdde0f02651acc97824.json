{
  "language": "Solidity",
  "sources": {
    "contracts/Sale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// Import our custom contracts\nimport \"./SaleBase.sol\";\nimport \"./StakingManager.sol\";\n\n/**\n * @title PreSale and Staking Contract\n * @notice This contract handles token presale, referral rewards, and staking functionality\n * @dev All tokens (presale, referral, staking) must be sent to the contract before starting\n *\n * Token Allocation:\n * - 30% for presale (30,000,000,000 tokens)\n * - 5% for referral rewards (5,000,000,000 tokens)\n * - 20% for staking rewards (20,000,000,000 tokens)\n *\n * Total: 55% of total supply must be transferred to this contract\n */\ncontract Sale is StakingManager {\n    /**\n     * @dev Constructor sets up the contract parameters\n     * @param _oracle Chainlink oracle for ETH price feed\n     * @param _usdt USDT token address\n     * @param _SaleToken Sale token address\n     * @param _MinTokenTobuy Minimum tokens that can be purchased\n     * @param _totalTokenSupply Total token supply (100,000,000,000)\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) \n      StakingManager(_oracle, _usdt, _SaleToken, _MinTokenTobuy, _totalTokenSupply)\n    {\n        // No additional initialization needed\n    }\n\n    /**\n     * @dev To buy into a presale using USDT with option for immediate staking\n     * @param usdAmount USDT amount to buy tokens\n     * @param referrer Referrer address (optional, use address(0) for no referrer)\n     * @param shouldStake If true, tokens are immediately staked for 1 year with 200% APY\n     */\n    function buyWithUSDT(\n        uint256 usdAmount, \n        address referrer, \n        bool shouldStake\n    ) external\n        checkPresaleId(presaleId)\n        checkSaleState(presaleId, usdtToTokens(presaleId, usdAmount))\n        nonReentrant\n        returns (bool)\n    {\n        require(isTokenPreFunded, \"Contract not pre-funded with tokens\");\n        require(!paused[presaleId], \"Presale paused\");\n        require(presale[presaleId].Active == true, \"Presale is not active yet\");\n        require(presale[presaleId].amountRaised + usdAmount <= presale[presaleId].UsdtHardcap,\n        \"Amount should be less than leftHardcap\");\n\n        // Handle referral if provided and not zero address\n        if (referrer != address(0)) {\n            // Security check to prevent contract-based referrals (potential attack vector)\n            require(!isContract(referrer), \"Referrer cannot be a contract\");\n            recordReferral(referrer);\n        }\n\n        uint256 tokens = usdtToTokens(presaleId, usdAmount);\n        presale[presaleId].Sold += tokens;\n        presale[presaleId].amountRaised += usdAmount;\n\n        if (isExcludeMinToken[msg.sender] == false) {\n            require(tokens >= MinTokenTobuy, \"Less than min amount\");\n        }\n\n        uint256 ourAllowance = USDTInterface.allowance(\n            _msgSender(),\n            address(this)\n        );\n        require(usdAmount <= ourAllowance, \"Make sure to add enough allowance\");\n        (bool success, ) = address(USDTInterface).call(\n            abi.encodeWithSignature(\n                \"transferFrom(address,address,uint256)\",\n                _msgSender(),\n                fundReceiver,\n                usdAmount\n            )\n        );\n        require(success, \"Token payment failed\");\n        \n        // Process referral rewards only if referrer is not zero address\n        if (referrer != address(0)) {\n            processReferralRewards(_msgSender(), tokens);\n        }\n        \n        // Handle tokens based on staking preference\n        if (shouldStake) {\n            // Directly stake tokens since the contract is pre-funded\n            _handleTokenStaking(_msgSender(), tokens);\n        } else {\n            // Record for later claiming\n            if (userClaimData[_msgSender()][presaleId].totalAmount > 0) {\n                userClaimData[_msgSender()][presaleId].totalAmount += tokens;\n            } else {\n                userClaimData[_msgSender()][presaleId] = ClaimData(0, tokens, 0);\n            }\n        }\n        \n        emit TokensBought(\n            _msgSender(),\n            presaleId,\n            address(USDTInterface),\n            tokens,\n            usdAmount,\n            block.timestamp\n        );\n        \n        return true;\n    }\n\n    /**\n     * @dev To buy into a presale using ETH with option for immediate staking\n     * @param referrer Referrer address (optional, use address(0) for no referrer)\n     * @param shouldStake If true, tokens are immediately staked for 1 year with 200% APY\n     */\n    function buyWithEth(\n        address referrer, \n        bool shouldStake\n    ) external\n        payable\n        checkPresaleId(presaleId)\n        checkSaleState(presaleId, ethToTokens(presaleId, msg.value))\n        nonReentrant\n        returns (bool)\n    {\n        require(isTokenPreFunded, \"Contract not pre-funded with tokens\");\n        uint256 usdAmount = (msg.value * getLatestPrice() * USDT_MULTIPLIER) / (ETH_MULTIPLIER * ETH_MULTIPLIER);\n        require(presale[presaleId].amountRaised + usdAmount <= presale[presaleId].UsdtHardcap,\n        \"Amount should be less than leftHardcap\");\n\n        require(!paused[presaleId], \"Presale paused\");\n        require(presale[presaleId].Active == true, \"Presale is not active yet\");\n        \n        // Handle referral if provided and not zero address\n        if (referrer != address(0)) {\n            // Security check to prevent contract-based referrals\n            require(!isContract(referrer), \"Referrer cannot be a contract\");\n            recordReferral(referrer);\n        }\n\n        uint256 tokens = usdtToTokens(presaleId, usdAmount);\n        if (isExcludeMinToken[msg.sender] == false) {\n            require(tokens >= MinTokenTobuy, \"Insufficient amount!\");\n        }\n        presale[presaleId].Sold += tokens;\n        presale[presaleId].amountRaised += usdAmount;\n\n        // Process referral rewards only if referrer is not zero address\n        if (referrer != address(0)) {\n            processReferralRewards(_msgSender(), tokens);\n        }\n\n        // Handle tokens based on staking preference\n        if (shouldStake) {\n            // Directly stake tokens since the contract is pre-funded\n            _handleTokenStaking(_msgSender(), tokens);\n        } else {\n            // Record for later claiming\n            if (userClaimData[_msgSender()][presaleId].totalAmount > 0) {\n                userClaimData[_msgSender()][presaleId].totalAmount += tokens;\n            } else {\n                userClaimData[_msgSender()][presaleId] = ClaimData(\n                    0, // Last claimed at\n                    tokens, // total tokens to be claimed\n                    0 // claimed amount\n                );\n            }\n        }\n\n        sendValue(payable(fundReceiver), msg.value);\n        emit TokensBought(\n            _msgSender(),\n            presaleId,\n            address(0),\n            tokens,\n            msg.value,\n            block.timestamp\n        );\n        \n        return true;\n    }\n    \n    /**\n     * @dev Modified claim function to handle only non-staked tokens\n     * @param _id Presale id\n     */\n    function claimAmount(uint256 _id)\n        public\n        override\n        checkPresaleId(_id)\n        returns (bool)\n    {\n        uint256 amount = claimableAmount(msg.sender, _id);\n        \n        require(amount > 0, \"Zero claim amount\");\n        require(\n            SaleToken != address(0),\n            \"Presale token address not set\"\n        );\n        require(\n            amount <= IERC20(SaleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n\n        require((presale[_id].isEnableClaim == true), \"Claim is not enable\");\n\n        userClaimData[msg.sender][_id].claimAt = block.timestamp;\n        userClaimData[msg.sender][_id].claimedAmount += amount;\n        \n        // Check if the user has set staking intent\n        if (userStakingIntent[msg.sender]) {\n            // Stake all tokens directly\n            _handleTokenStaking(msg.sender, amount);\n            \n            // Reset staking intent after processing\n            userStakingIntent[msg.sender] = false;\n        } else {\n            // Normal token transfer for non-staking users\n            bool success = IERC20(SaleToken).transfer(msg.sender, amount);\n            require(success, \"Token transfer failed\");\n        }\n        \n        emit TokensClaimedWithTimestamp(msg.sender, _id, amount, block.timestamp);\n        return true;\n    }\n\n    function WithdrawTokens(address _token, uint256 amount) external override onlyOwner {\n        if (_token == SaleToken) {\n            // Calculate tokens needed for rewards and stakes\n            uint256 reservedTokens = totalReferralRewardsIssued +\n                // Staked tokens plus their potential rewards\n                totalStaked * (STAKING_APY + 100) / PERCENT_DENOMINATOR;\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(\n                contractBalance - amount >= reservedTokens,\n                \"Cannot withdraw tokens reserved for rewards\"\n            );\n        }\n        \n        bool success = IERC20(_token).transfer(fundReceiver, amount);\n        require(success, \"Token transfer failed\");\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/SaleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\ninterface Aggregator {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/**\n * @title Sale Base Contract\n * @notice This contract handles the core presale and referral functionality\n */\ncontract SaleBase is ReentrancyGuard, Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    \n    // Constants\n    uint256 public constant PERCENT_DENOMINATOR = 100;\n    uint256 public constant REFERRAL_PERCENTAGE = 5; // 5% referral bonus\n    uint256 public constant TOKEN_DECIMALS = 10**18;\n    uint256 internal constant TOKEN_PRICE_PRECISION = 10**18;\n    \n    // State variables\n    address public oracle; // Chainlink oracle address\n    address public usdt; // USDT token address\n    address public SaleToken; // Sale token address\n    uint256 public MinTokenTobuy; // Min tokens to buy\n    uint256 public TotalAmountBought; // Total tokens bought\n    uint256 public TotalUSDTRaised; // Total USDT raised\n    uint256 public TotalReferralAmount; // Total referral rewards\n    uint256 public totalTokenSupply; // Total supply of tokens\n    \n    // Presale structure (renamed from original to avoid duplicates)\n    struct PresaleInfo {\n        uint256 cap; // Max tokens to sell\n        uint256 price; // Price in USDT decimals\n        uint256 sold; // Tokens already sold\n        uint256 startTime; // Start timestamp\n        uint256 endTime; // End timestamp\n        bool ClaimAble; // Tokens can be claimed\n        bool isClosed; // Presale is closed \n    }\n    \n    // user structure\n    struct User {\n        uint256 TotalBoughtTokens; // Total tokens purchased\n        uint256 TotalPaid; // Total USDT paid\n        uint256 TotalCollectedReferral; // Total referral earned\n        uint256 lastClaimTime; // Last token claim time\n        address[] referredUsers; // Users referred\n        address referrer; // User's referrer\n    }\n    \n    // Array of presales\n    PresaleInfo[] public presales;\n    \n    // User's purchases in each presale\n    mapping(address => mapping(uint256 => uint256)) public UserPresaleBuying;\n    \n    // User's token claims\n    mapping(address => mapping(uint256 => bool)) public Claimed;\n    \n    // User data\n    mapping(address => User) public users;\n    \n    // Whitelist status\n    mapping(address => bool) public isWhitelisted;\n    \n    // Admin addresses\n    mapping(address => bool) public isAdmin;\n    \n    // Events\n    event PresaleStarted(\n        uint256 presaleId, \n        uint256 cap, \n        uint256 price, \n        uint256 startTime, \n        uint256 endTime\n    );\n    \n    event PresaleEnded(\n        uint256 presaleId, \n        uint256 endTime\n    );\n    \n    event TokensPurchased(\n        address indexed buyer, \n        uint256 presaleId, \n        uint256 amount, \n        uint256 usdtAmount\n    );\n    \n    event TokensClaimed(\n        address indexed user,\n        uint256 indexed id,\n        uint256 amount,\n        uint256 timestamp\n    );\n    \n    event ReferralProcessed(\n        address indexed referrer, \n        address indexed referred, \n        uint256 amount\n    );\n    \n    event WhitelistStatusChanged(\n        address indexed user, \n        bool isWhitelisted, \n        uint256 timestamp\n    );\n    \n    event AdminStatusChanged(\n        address indexed user, \n        bool isAdmin, \n        uint256 timestamp\n    );\n    \n    event OracleUpdated(\n        address previousOracle, \n        address newOracle, \n        uint256 timestamp\n    );\n    \n    event PresaleClaimableStatusChanged(\n        uint256 presaleId, \n        bool isClaimable, \n        uint256 timestamp\n    );\n    \n    event PresaleClosedStatusChanged(\n        uint256 presaleId, \n        bool isClosed, \n        uint256 timestamp\n    );\n    \n    event MinTokensToUSDT(\n        uint256 previousMinimum, \n        uint256 newMinimum, \n        uint256 timestamp\n    );\n    \n    uint256 public presaleId;\n    uint256 public USDT_MULTIPLIER;\n    uint256 public ETH_MULTIPLIER;\n    address public fundReceiver;\n\n    // Token allocation constants\n    uint256 public constant PRESALE_ALLOCATION_PERCENT = 30;\n    uint256 public constant REFERRAL_ALLOCATION_PERCENT = 5;\n    uint256 public constant STAKING_ALLOCATION_PERCENT = 20;\n    \n    // Total supply and allocations\n    uint256 public presaleTokens;\n    uint256 public maxReferralRewards;\n    uint256 private _maxStakingRewards; // Private state variable instead\n\n    // Referral system constants and variables\n    uint256 public constant MINIMUM_PURCHASE_FOR_REFERRAL = 1000 * TOKEN_DECIMALS; // 1000 tokens minimum to qualify for referral\n    uint256 public referralRewardPercentage = 20; // Default 20% reward (configurable)\n    uint256 public constant MAX_REFERRAL_PERCENTAGE = 20; // Maximum allowed reward percentage\n    uint256 public totalReferralRewardsIssued;\n    uint256 public constant REFERRAL_DENOMINATOR = 100; // For percentage calculations\n\n    // Anti-gaming time lock for referral changes\n    uint256 public referralPercentageChangeTimeLock;\n    uint256 public constant REFERRAL_CHANGE_TIMELOCK = 24 hours;\n\n    // Presale structure (used in actual implementation)\n    struct Presale {\n        uint256 startTime;\n        uint256 endTime;\n        uint256 price;\n        uint256 nextStagePrice;\n        uint256 Sold;\n        uint256 tokensToSell;\n        uint256 UsdtHardcap;\n        uint256 amountRaised;\n        bool Active;\n        bool isEnableClaim;\n    }\n\n    struct ClaimData {\n        uint256 claimAt;\n        uint256 totalAmount;\n        uint256 claimedAmount;\n    }\n\n    // Referral data structure\n    struct ReferralData {\n        address referrer;\n        uint256 totalReferralRewards;\n        uint256 claimedReferralRewards;\n        bool hasReferred; // Flag to check if user has made at least one referral\n        uint256 referralCount; // Track number of successful referrals\n    }\n\n    IERC20Metadata public USDTInterface;\n    Aggregator internal aggregatorInterface;\n    // https://docs.chain.link/docs/ethereum-addresses/ => (ETH / USD)\n\n    mapping(uint256 => bool) public paused;\n    mapping(uint256 => Presale) public presale;\n    mapping(address => mapping(uint256 => ClaimData)) public userClaimData;\n    mapping(address => bool) public isExcludeMinToken;\n    \n    // Referral system mappings\n    mapping(address => ReferralData) public referralData;\n    mapping(address => bool) public hasQualifiedPurchase; // Track if user has purchased enough to qualify as referrer\n    mapping(address => bool) public hasUsedReferral; // Prevent using multiple referrals\n\n    // Mapping to track users who want to stake ALL their tokens upon claim\n    mapping(address => bool) public userStakingIntent;\n\n    // Track if the contract has been pre-funded\n    bool public isTokenPreFunded = false;\n\n    event TokensPreFunded(address indexed token, uint256 amount, uint256 timestamp);\n    \n    event PresaleCreated(\n        uint256 indexed _id,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime\n    );\n\n    event PresaleUpdated(\n        bytes32 indexed key,\n        uint256 prevValue,\n        uint256 newValue,\n        uint256 timestamp\n    );\n\n    event TokensBought(\n        address indexed user,\n        uint256 indexed id,\n        address indexed purchaseToken,\n        uint256 tokensBought,\n        uint256 amountPaid,\n        uint256 timestamp\n    );\n\n    event TokensClaimedWithTimestamp(\n        address indexed user,\n        uint256 indexed id,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event PresaleTokenAddressUpdated(\n        address indexed prevValue,\n        address indexed newValue,\n        uint256 timestamp\n    );\n\n    event PresalePaused(uint256 indexed id, uint256 timestamp);\n    event PresaleUnpaused(uint256 indexed id, uint256 timestamp);\n    \n    // Referral Events\n    event ReferralRecorded(\n        address indexed referrer, \n        address indexed referee, \n        uint256 timestamp\n    );\n    \n    event ReferralRewardsClaimed(\n        address indexed user, \n        uint256 amount, \n        uint256 timestamp\n    );\n    \n    event ReferralPercentageUpdated(\n        uint256 previousPercentage, \n        uint256 newPercentage, \n        uint256 timestamp\n    );\n    \n    event ReferralRewardsAdded(\n        address indexed referrer, \n        address indexed referee, \n        uint256 referrerReward, \n        uint256 refereeReward, \n        uint256 timestamp\n    );\n\n    /**\n     * @dev Constructor initializes the sale parameters\n     * @param _oracle Chainlink oracle for ETH price feed\n     * @param _usdt USDT token address\n     * @param _SaleToken Sale token address\n     * @param _MinTokenTobuy Minimum tokens that can be purchased\n     * @param _totalTokenSupply Total token supply\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) Ownable(msg.sender) {\n        _initialize(_oracle, _usdt, _SaleToken, _MinTokenTobuy, _totalTokenSupply);\n    }\n    \n    /**\n     * @dev Internal initialization function to initialize without calling Ownable\n     */\n    function _initialize(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) internal {\n        require(_oracle != address(0), \"Oracle address cannot be zero\");\n        require(_usdt != address(0), \"USDT address cannot be zero\");\n        require(_SaleToken != address(0), \"Sale token address cannot be zero\");\n        require(_MinTokenTobuy > 0, \"Minimum token to buy must be greater than zero\");\n        require(_totalTokenSupply > 0, \"Total supply must be greater than zero\");\n        \n        aggregatorInterface = Aggregator(_oracle);\n        SaleToken = _SaleToken;\n        MinTokenTobuy = _MinTokenTobuy;\n        USDTInterface = IERC20Metadata(_usdt);\n        ETH_MULTIPLIER = (10**18);\n        USDT_MULTIPLIER =(10**6);\n        fundReceiver = msg.sender;\n        \n        // Store total supply\n        totalTokenSupply = _totalTokenSupply;\n        \n        // Calculate allocations\n        presaleTokens = _totalTokenSupply * PRESALE_ALLOCATION_PERCENT / PERCENT_DENOMINATOR; // 30% for presale\n        maxReferralRewards = _totalTokenSupply * REFERRAL_ALLOCATION_PERCENT / PERCENT_DENOMINATOR; // 5% for referrals\n        _maxStakingRewards = _totalTokenSupply * STAKING_ALLOCATION_PERCENT / PERCENT_DENOMINATOR; // 20% for staking rewards\n    }\n    \n    /**\n     * @dev Pre-fund the contract with tokens for presale, referrals, and staking\n     * @notice Before calling this function:\n     * 1. Deploy the token contract\n     * 2. Transfer 55% of total supply to this contract address\n     * 3. Call this function to verify and activate the pre-funding\n     *\n     * This marks the contract as ready for presale with tokens available for:\n     * - Direct distribution for non-staking purchases\n     * - Immediate staking during purchase (no need to claim first)\n     * - Referral reward distribution\n     */\n    function preFundContract() external onlyOwner {\n        require(!isTokenPreFunded, \"Contract already pre-funded\");\n        require(SaleToken != address(0), \"Sale token not set\");\n        \n        // Calculate total tokens needed\n        uint256 totalRequired = presaleTokens + maxReferralRewards + _maxStakingRewards;\n        \n        // Check contract balance\n        uint256 contractBalance = IERC20(SaleToken).balanceOf(address(this));\n        require(contractBalance >= totalRequired, \"Insufficient token balance\");\n        \n        // Set pre-funded flag\n        isTokenPreFunded = true;\n        \n        emit TokensPreFunded(SaleToken, contractBalance, block.timestamp);\n    }\n\n    /**\n     * @dev Update the maximum referral rewards (5% of total supply)\n     * @param _totalSupply The total token supply to calculate 5% from\n     */\n    function updateMaxReferralRewards(uint256 _totalSupply) external onlyOwner {\n        require(_totalSupply > 0, \"Invalid total supply\");\n        maxReferralRewards = _totalSupply * REFERRAL_ALLOCATION_PERCENT / PERCENT_DENOMINATOR;\n    }\n\n    /**\n     * @dev Change referral reward percentage with timelock protection\n     * @param _percentage New percentage (1-20)\n     */\n    function updateReferralRewardPercentage(uint256 _percentage) external onlyOwner {\n        require(_percentage > 0 && _percentage <= MAX_REFERRAL_PERCENTAGE, \"Invalid percentage\");\n        require(block.timestamp >= referralPercentageChangeTimeLock, \"Timelock active\");\n        \n        // Set new timelock for future changes\n        referralPercentageChangeTimeLock = block.timestamp + REFERRAL_CHANGE_TIMELOCK;\n        \n        uint256 oldPercentage = referralRewardPercentage;\n        referralRewardPercentage = _percentage;\n        \n        emit ReferralPercentageUpdated(oldPercentage, _percentage, block.timestamp);\n    }\n\n    /**\n     * @dev Records a valid referral relationship\n     * @param _referrer Address of the referrer\n     */\n    function recordReferral(address _referrer) internal {\n        // Security checks\n        require(_referrer != address(0), \"Invalid referrer\");\n        require(_referrer != msg.sender, \"Cannot refer yourself\");\n        require(!hasUsedReferral[msg.sender], \"Already used a referral\");\n        require(hasQualifiedPurchase[_referrer], \"Referrer has not qualified\");\n        \n        // Record the referral relationship\n        referralData[msg.sender].referrer = _referrer;\n        hasUsedReferral[msg.sender] = true;\n        \n        // Update referrer stats\n        referralData[_referrer].hasReferred = true;\n        referralData[_referrer].referralCount++;\n        \n        emit ReferralRecorded(_referrer, msg.sender, block.timestamp);\n    }\n\n    /**\n     * @dev Process referral rewards after a successful purchase\n     * @param _user Address of the user who made a purchase\n     * @param _tokenAmount Amount of tokens purchased\n     */\n    function processReferralRewards(address _user, uint256 _tokenAmount) internal {\n        // Check if purchase meets minimum for referral qualification\n        if (_tokenAmount >= MINIMUM_PURCHASE_FOR_REFERRAL) {\n            hasQualifiedPurchase[_user] = true;\n        }\n        \n        // If user has a referrer, calculate and assign rewards\n        address referrer = referralData[_user].referrer;\n        if (referrer != address(0) && _tokenAmount >= MINIMUM_PURCHASE_FOR_REFERRAL) {\n            // Calculate rewards (both get the same percentage)\n            uint256 referrerReward = _tokenAmount * referralRewardPercentage / REFERRAL_DENOMINATOR;\n            uint256 refereeReward = referrerReward; // Same reward for both parties\n            \n            // Check against the max referral rewards cap\n            uint256 totalNewRewards = referrerReward + refereeReward;\n            if (totalReferralRewardsIssued + totalNewRewards <= maxReferralRewards) {\n                // Update referrer's rewards\n                referralData[referrer].totalReferralRewards = \n                    referralData[referrer].totalReferralRewards + referrerReward;\n                \n                // Update referee's rewards\n                referralData[_user].totalReferralRewards = \n                    referralData[_user].totalReferralRewards + refereeReward;\n                \n                // Update total rewards issued\n                totalReferralRewardsIssued = totalReferralRewardsIssued + totalNewRewards;\n                \n                emit ReferralRewardsAdded(\n                    referrer, \n                    _user, \n                    referrerReward, \n                    refereeReward, \n                    block.timestamp\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Get claimable referral rewards for a user\n     * @param _user Address of the user\n     */\n    function getClaimableReferralRewards(address _user) public view returns (uint256) {\n        ReferralData memory data = referralData[_user];\n        return data.totalReferralRewards - data.claimedReferralRewards;\n    }\n\n    /**\n     * @dev Claim referral rewards\n     */\n    function claimReferralRewards() external nonReentrant returns (bool) {\n        uint256 amount = getClaimableReferralRewards(msg.sender);\n        require(amount > 0, \"No rewards to claim\");\n        \n        // Verify there are enough tokens in the contract\n        require(\n            amount <= IERC20(SaleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n        \n        // Update claimed amount\n        referralData[msg.sender].claimedReferralRewards = \n            referralData[msg.sender].claimedReferralRewards + amount;\n        \n        // Transfer tokens\n        bool success = IERC20(SaleToken).transfer(msg.sender, amount);\n        require(success, \"Token transfer failed\");\n        \n        emit ReferralRewardsClaimed(msg.sender, amount, block.timestamp);\n        return true;\n    }\n\n    // Utility function to check if an address is a contract\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    function ChangeTokenToSell(address _token) public onlyOwner {\n        SaleToken = _token;\n    }\n\n    function EditMinTokenToBuy(uint256 _amount) public onlyOwner {\n        MinTokenTobuy = _amount;\n    }\n\n    function createPresale(uint256 _price,uint256 _nextStagePrice, uint256 _tokensToSell, uint256 _UsdtHardcap)\n        external\n        onlyOwner\n    {\n        require(_price > 0, \"Zero price\");\n        require(_tokensToSell > 0, \"Zero tokens to sell\");\n        require(presale[presaleId].Active == false, \"Previous Sale is Active\");\n\n        presaleId++;\n\n        presale[presaleId] = Presale(\n            0,\n            0,\n            _price,\n            _nextStagePrice,\n            0,\n            _tokensToSell,\n            _UsdtHardcap,\n            0,\n            false,\n            false\n        );\n\n        emit PresaleCreated(presaleId, _tokensToSell, 0, 0);\n    }\n\n    function startPresale() public onlyOwner {\n        presale[presaleId].startTime = block.timestamp;\n        presale[presaleId].Active = true;\n    }\n\n    function endPresale() public onlyOwner {\n        require(\n            presale[presaleId].Active == true,\n            \"This presale is already Inactive\"\n        );\n        presale[presaleId].endTime = block.timestamp;\n        presale[presaleId].Active = false;\n    }\n\n    // @dev enabel Claim amount\n    function enableClaim(uint256 _id, bool _status)\n        public\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        presale[_id].isEnableClaim = _status;\n    }\n\n    function updatePresale(\n        uint256 _id,\n        uint256 _price,\n        uint256 _nextStagePrice,\n        uint256 _tokensToSell,\n        uint256 _Hardcap\n    ) external checkPresaleId(_id) onlyOwner {\n        require(_price > 0, \"Zero price\");\n        require(_tokensToSell > 0, \"Zero tokens to sell\");\n        presale[_id].price = _price;\n        presale[_id].nextStagePrice = _nextStagePrice;\n        presale[_id].tokensToSell = _tokensToSell;\n        presale[_id].UsdtHardcap =_Hardcap;\n    }\n\n    /**\n     * @dev To update the fund receiving wallet\n     * @param _wallet address of wallet to update\n\n     */\n    function changeFundWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Invalid parameters\");\n        fundReceiver = _wallet;\n    }\n\n    /**\n     * @dev To update the USDT Token address\n     * @param _newAddress Sale token address\n     */\n    function changeUSDTToken(address _newAddress) external onlyOwner {\n        require(_newAddress != address(0), \"Zero token address\");\n        USDTInterface = IERC20Metadata(_newAddress);\n    }\n\n    /**\n     * @dev To pause the presale\n     * @param _id Presale id to update\n     */\n    function pausePresale(uint256 _id) external checkPresaleId(_id) onlyOwner {\n        require(!paused[_id], \"Already paused\");\n        paused[_id] = true;\n        emit PresalePaused(_id, block.timestamp);\n    }\n\n    /**\n     * @dev To unpause the presale\n     * @param _id Presale id to update\n     */\n    function unPausePresale(uint256 _id)\n        external\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        require(paused[_id], \"Not paused\");\n        paused[_id] = false;\n        emit PresaleUnpaused(_id, block.timestamp);\n    }\n\n    /**\n     * @dev To get latest ethereum price in 10**18 format\n     */\n    function getLatestPrice() public view returns (uint256) {\n        (, int256 price, , , ) = aggregatorInterface.latestRoundData();\n        price = (price * (10**10));\n        return uint256(price);\n    }\n\n    modifier checkPresaleId(uint256 _id) {\n        require(_id > 0 && _id <= presaleId, \"Invalid presale id\");\n        _;\n    }\n\n    modifier checkSaleState(uint256 _id, uint256 amount) {\n        require(\n            block.timestamp >= presale[_id].startTime &&\n                presale[_id].Active == true,\n            \"Invalid time for buying\"\n        );\n        require(\n            amount > 0 && amount <= presale[_id].tokensToSell-presale[_id].Sold,\n            \"Invalid sale amount\"\n        );\n        _;\n    }\n\n    function ExcludeAccouctFromMinBuy(address _user, bool _status)\n        external\n        onlyOwner\n    {\n        isExcludeMinToken[_user] = _status;\n    }\n\n    /**\n     * @dev Helper funtion to get ETH price for given amount\n     * @param _id Presale id\n     * @param amount No of tokens to buy\n     */\n    function ethBuyHelper(uint256 _id, uint256 amount)\n        external\n        view\n        checkPresaleId(_id)\n        returns (uint256 ethAmount)\n    {\n        uint256 usdPrice = (amount * presale[_id].price);\n        ethAmount = (usdPrice * ETH_MULTIPLIER) / (getLatestPrice() * 10**IERC20Metadata(SaleToken).decimals());\n    }\n\n    /**\n     * @dev Helper funtion to get USDT price for given amount\n     * @param _id Presale id\n     * @param amount No of tokens to buy\n     */\n    function usdtBuyHelper(uint256 _id, uint256 amount)\n        external\n        view\n        checkPresaleId(_id)\n        returns (uint256 usdPrice)\n    {\n        usdPrice = (amount * presale[_id].price) / 10**IERC20Metadata(SaleToken).decimals();\n    }\n\n    /**\n     * @dev Helper funtion to get tokens for eth amount\n     * @param _id Presale id\n     * @param amount No of eth\n     */\n    function ethToTokens(uint256 _id, uint256 amount)\n        public\n        view\n        returns (uint256 _tokens)\n    {\n        uint256 usdAmount = amount * getLatestPrice() * USDT_MULTIPLIER / (ETH_MULTIPLIER * ETH_MULTIPLIER);\n        _tokens = usdtToTokens(_id, usdAmount);\n    }\n\n    /**\n     * @dev Helper funtion to get tokens for given usdt amount\n     * @param _id Presale id\n     * @param amount No of usdt\n     */\n    function usdtToTokens(uint256 _id, uint256 amount)\n        public\n        view\n        checkPresaleId(_id)\n        returns (uint256 _tokens)\n    {\n        _tokens = (amount * presale[_id].price) / USDT_MULTIPLIER;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Low balance\");\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"ETH Payment failed\");\n    }\n\n    function unlockToken(uint256 _id)\n        public\n        view\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        require(\n            block.timestamp >= presale[_id].endTime,\n            \"You can only unlock on finalize\"\n        );\n    }\n\n    /**\n     * @dev Helper funtion to get claimable tokens for a given presale.\n     * @param user User address\n     * @param _id Presale id\n     */\n    function claimableAmount(address user, uint256 _id)\n        public\n        view\n        checkPresaleId(_id)\n        returns (uint256)\n    {\n        ClaimData memory _user = userClaimData[user][_id];\n\n        require(_user.totalAmount > 0, \"Nothing to claim\");\n        uint256 amount = _user.totalAmount - _user.claimedAmount;\n        require(amount > 0, \"Already claimed\");\n        return amount;\n    }\n\n    /**\n     * @dev To claim tokens from a multiple presale\n     * @param _id Presale id\n     */\n    function claimMultiple(uint256[] calldata _id) external returns (bool) {\n        require(_id.length > 0, \"Zero ID length\");\n        for (uint256 i; i < _id.length; i++) {\n            require(claimAmount(_id[i]), \"Claim failed\");\n        }\n        return true;\n    }\n    \n    /**\n     * @dev Modified claim function to handle only non-staked tokens\n     * @param _id Presale id\n     */\n    function claimAmount(uint256 _id)\n        public \n        virtual\n        checkPresaleId(_id)\n        returns (bool)\n    {\n        uint256 amount = claimableAmount(msg.sender, _id);\n        \n        require(amount > 0, \"Zero claim amount\");\n        require(\n            SaleToken != address(0),\n            \"Presale token address not set\"\n        );\n        require(\n            amount <= IERC20(SaleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n\n        require((presale[_id].isEnableClaim == true), \"Claim is not enable\");\n\n        userClaimData[msg.sender][_id].claimAt = block.timestamp;\n        userClaimData[msg.sender][_id].claimedAmount += amount;\n        \n        bool success = IERC20(SaleToken).transfer(msg.sender, amount);\n        require(success, \"Token transfer failed\");\n        \n        emit TokensClaimedWithTimestamp(msg.sender, _id, amount, block.timestamp);\n        return true;\n    }\n    \n    // Add functions to get user referral status for the frontend\n    function getUserReferralInfo(address _user) external view returns (\n        address referrer,\n        uint256 totalRewards,\n        uint256 claimedRewards,\n        uint256 pendingRewards,\n        bool isQualifiedReferrer,\n        uint256 referralCount\n    ) {\n        ReferralData memory data = referralData[_user];\n        return (\n            data.referrer,\n            data.totalReferralRewards,\n            data.claimedReferralRewards,\n            data.totalReferralRewards - data.claimedReferralRewards,\n            hasQualifiedPurchase[_user],\n            data.referralCount\n        );\n    }\n\n    // Get referral program stats\n    function getReferralProgramStats() external view returns (\n        uint256 currentPercentage,\n        uint256 totalRewardsIssued,\n        uint256 maxRewards,\n        uint256 remainingRewards,\n        uint256 nextPercentageChangeAllowed\n    ) {\n        return (\n            referralRewardPercentage,\n            totalReferralRewardsIssued,\n            maxReferralRewards,\n            maxReferralRewards - totalReferralRewardsIssued,\n            referralPercentageChangeTimeLock\n        );\n    }\n\n    // Check if a user has a valid referral link to share\n    function canReferOthers(address _user) external view returns (bool) {\n        return hasQualifiedPurchase[_user];\n    }\n\n    function WithdrawTokens(address _token, uint256 amount) external virtual onlyOwner {\n        if (_token == SaleToken) {\n            // Calculate tokens needed for rewards\n            uint256 reservedTokens = totalReferralRewardsIssued;\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(\n                contractBalance - amount >= reservedTokens,\n                \"Cannot withdraw tokens reserved for rewards\"\n            );\n        }\n        \n        IERC20(_token).transfer(fundReceiver, amount);\n    }\n\n    function WithdrawContractFunds(uint256 amount) external onlyOwner {\n        sendValue(payable(fundReceiver), amount);\n    }\n\n    /**\n     * Accessor function for maxStakingRewards\n     */\n    function maxStakingRewards() public view virtual returns (uint256) {\n        return _maxStakingRewards;\n    }\n} "
    },
    "contracts/StakingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Import SaleBase \nimport \"./SaleBase.sol\";\n\n/**\n * @title Staking Manager Contract\n * @notice This contract handles token staking functionality\n */\ncontract StakingManager is SaleBase {\n    // Keep some constants to maintain internal functionality\n    uint256 internal constant TOKEN_DECIMALS_INT = 10**18;\n    uint256 internal constant PERCENT_DENOMINATOR_INT = 100;\n    \n    // Staking system constants and variables\n    uint256 public constant STAKING_LOCK_PERIOD = 365 days; // 365 days\n    uint256 public constant STAKING_APY = 200; // 200% APY\n    uint256 public totalStaked;\n    uint256 public stakingCap; // Cap at 6,666,666,667 tokens\n    bool public stakingActive;\n    uint256 public totalStakingRewardsIssued;\n    \n    // Maximum staking rewards allocation (shadows the one in SaleBase)\n    uint256 private _maxStakingRewards;\n    \n    // Staking data structure\n    struct StakeInfo {\n        uint256 stakedAmount;\n        uint256 stakingTimestamp;\n        uint256 unlockTimestamp;\n        bool hasWithdrawn;\n    }\n    \n    // Staking system mappings\n    mapping(address => StakeInfo) public userStakes;\n\n    // New Staking Events\n    event TokensStaked(\n        address indexed user, \n        uint256 amount, \n        uint256 stakingTime, \n        uint256 unlockTime\n    );\n\n    event StakeWithdrawn(\n        address indexed user, \n        uint256 stakedAmount, \n        uint256 rewardAmount, \n        uint256 timestamp\n    );\n\n    event StakingStatusChanged(\n        bool isActive,\n        uint256 timestamp\n    );\n    \n    event StakingCapUpdated(\n        uint256 previousCap,\n        uint256 newCap,\n        uint256 timestamp\n    );\n    \n    /**\n     * @dev Constructor initializes staking and sale parameters\n     * @param _oracle Chainlink oracle for ETH price feed\n     * @param _usdt USDT token address\n     * @param _saleToken Sale token address\n     * @param _MinTokenTobuy Minimum tokens that can be purchased\n     * @param _totalTokenSupply Total token supply\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _saleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) \n        SaleBase(_oracle, _usdt, _saleToken, _MinTokenTobuy, _totalTokenSupply) \n    {\n        // Initialize staking parameters\n        stakingCap = 6666666667 * TOKEN_DECIMALS_INT; // 6,666,666,667 tokens\n        stakingActive = true; // Staking is active by default\n        \n        // Calculate maximum staking rewards (20% of total supply)\n        _maxStakingRewards = _totalTokenSupply * 20 / PERCENT_DENOMINATOR_INT;\n    }\n    \n    /**\n     * @dev Maximum available tokens for staking rewards (20% of total supply)\n     * @return The maximum number of tokens available for staking rewards\n     */\n    function maxStakingRewards() public view override returns (uint256) {\n        return _maxStakingRewards;\n    }\n    \n    /**\n     * @dev Toggle staking status (active/inactive)\n     * @param _status New staking status\n     */\n    function setStakingStatus(bool _status) external onlyOwner {\n        stakingActive = _status;\n        emit StakingStatusChanged(_status, block.timestamp);\n    }\n\n    /**\n     * @dev Helper function that handles token staking directly during purchase\n     * @param _user Address of the user\n     * @param _amount Amount of tokens to stake\n     * @notice This function is called automatically during purchase if staking is selected\n     * @notice Tokens are locked for 365 days with 200% APY\n     */\n    function _handleTokenStaking(address _user, uint256 _amount) internal {\n        // Ensure staking is active\n        require(stakingActive, \"Staking is not active\");\n        require(_amount > 0, \"Cannot stake zero amount\");\n        require(\n            totalStaked + _amount <= stakingCap,\n            \"Staking cap would be exceeded\"\n        );\n        \n        // Calculate potential rewards to verify we stay within the rewards limit\n        uint256 potentialReward = _amount * STAKING_APY / PERCENT_DENOMINATOR_INT;\n        require(\n            totalStakingRewardsIssued + potentialReward <= maxStakingRewards(),\n            \"Not enough tokens in the staking reward pool\"\n        );\n        \n        // Update global state for staking\n        totalStaked = totalStaked + _amount;\n        totalStakingRewardsIssued = totalStakingRewardsIssued + potentialReward;\n        \n        // Auto-disable staking if cap is reached\n        if (totalStaked >= stakingCap) {\n            stakingActive = false;\n            emit StakingStatusChanged(false, block.timestamp);\n        }\n        \n        // Update user stake\n        StakeInfo storage userStake = userStakes[_user];\n        \n        // If user already has a stake, handle appropriately\n        if (userStake.stakedAmount > 0 && !userStake.hasWithdrawn) {\n            // If existing stake is still locked, cannot add to it\n            if (block.timestamp < userStake.unlockTimestamp) {\n                revert(\"Cannot stake when you have a locked stake\");\n            } else {\n                // Existing stake is unlocked, withdraw it first\n                uint256 stakedAmount = userStake.stakedAmount;\n                uint256 reward = stakedAmount * STAKING_APY / PERCENT_DENOMINATOR_INT;\n                \n                // Mark as withdrawn to prevent double-dipping\n                userStake.hasWithdrawn = true;\n                \n                // Transfer rewards and original stake back\n                bool transferSuccess = IERC20(SaleToken).transfer(_user, stakedAmount + reward);\n                require(transferSuccess, \"Stake withdrawal failed\");\n                \n                emit StakeWithdrawn(_user, stakedAmount, reward, block.timestamp);\n            }\n        }\n        \n        // Create a new stake\n        userStake.stakedAmount = _amount;\n        userStake.stakingTimestamp = block.timestamp;\n        userStake.unlockTimestamp = block.timestamp + STAKING_LOCK_PERIOD;\n        userStake.hasWithdrawn = false;\n        \n        emit TokensStaked(_user, _amount, block.timestamp, userStake.unlockTimestamp);\n    }\n\n    /**\n     * @dev Stake tokens with 1-year lock and 200% APY\n     * @param _amount Amount of tokens to stake\n     */\n    function stakeTokens(uint256 _amount) external nonReentrant {\n        require(stakingActive, \"Staking is not active\");\n        require(_amount > 0, \"Cannot stake zero amount\");\n        require(\n            totalStaked + _amount <= stakingCap,\n            \"Staking cap would be exceeded\"\n        );\n        \n        // Calculate potential rewards to verify we stay within the rewards limit\n        uint256 potentialReward = _amount * STAKING_APY / PERCENT_DENOMINATOR_INT;\n        require(\n            totalStakingRewardsIssued + potentialReward <= maxStakingRewards(),\n            \"Not enough tokens in the staking reward pool\"\n        );\n        \n        // Update global state\n        totalStaked = totalStaked + _amount;\n        totalStakingRewardsIssued = totalStakingRewardsIssued + potentialReward;\n        \n        // Auto-disable staking if cap is reached\n        if (totalStaked >= stakingCap) {\n            stakingActive = false;\n            emit StakingStatusChanged(false, block.timestamp);\n        }\n        \n        // Update user stake\n        StakeInfo storage userStake = userStakes[msg.sender];\n        \n        // If user already has a stake, we need special handling\n        if (userStake.stakedAmount > 0 && !userStake.hasWithdrawn) {\n            require(\n                block.timestamp >= userStake.unlockTimestamp,\n                \"Cannot add to existing stake while locked\"\n            );\n            \n            // Withdraw previous stake first (internally)\n            uint256 stakedAmount = userStake.stakedAmount;\n            uint256 reward = stakedAmount * STAKING_APY / PERCENT_DENOMINATOR_INT;\n            \n            // Mark as withdrawn to prevent double-dipping\n            userStake.hasWithdrawn = true;\n            \n            // Transfer rewards and original stake back\n            bool transferSuccess = IERC20(SaleToken).transfer(msg.sender, stakedAmount + reward);\n            require(transferSuccess, \"Token transfer failed\");\n            \n            // Create a new stake\n            userStake.stakedAmount = _amount;\n            userStake.stakingTimestamp = block.timestamp;\n            userStake.unlockTimestamp = block.timestamp + STAKING_LOCK_PERIOD;\n            userStake.hasWithdrawn = false;\n        } else {\n            // First time stake or previous stake was withdrawn\n            userStake.stakedAmount = _amount;\n            userStake.stakingTimestamp = block.timestamp;\n            userStake.unlockTimestamp = block.timestamp + STAKING_LOCK_PERIOD;\n            userStake.hasWithdrawn = false;\n        }\n        \n        // Transfer tokens from user to contract (SafeERC20 pattern)\n        uint256 balanceBefore = IERC20(SaleToken).balanceOf(address(this));\n        bool transferFromSuccess = IERC20(SaleToken).transferFrom(msg.sender, address(this), _amount);\n        require(transferFromSuccess, \"Token transfer failed\");\n        \n        // Verify tokens were actually received (protection against fee-on-transfer tokens)\n        uint256 balanceAfter = IERC20(SaleToken).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore + _amount, \"Incorrect amount of tokens received\");\n        \n        emit TokensStaked(msg.sender, _amount, block.timestamp, userStake.unlockTimestamp);\n    }\n    \n    /**\n     * @dev Withdraw staked tokens and rewards after lock period\n     */\n    function withdrawStake() external nonReentrant {\n        StakeInfo storage userStake = userStakes[msg.sender];\n        \n        require(userStake.stakedAmount > 0, \"No stake found\");\n        require(!userStake.hasWithdrawn, \"Already withdrawn\");\n        require(\n            block.timestamp >= userStake.unlockTimestamp,\n            \"Stake is still locked\"\n        );\n        \n        uint256 stakedAmount = userStake.stakedAmount;\n        uint256 reward = stakedAmount * STAKING_APY / PERCENT_DENOMINATOR_INT;\n        uint256 totalAmount = stakedAmount + reward;\n        \n        // Mark as withdrawn to prevent double-dipping\n        userStake.hasWithdrawn = true;\n        \n        // Update global state\n        totalStaked = totalStaked - stakedAmount;\n        \n        // Verify there are enough tokens in the contract\n        require(\n            totalAmount <= IERC20(SaleToken).balanceOf(address(this)),\n            \"Not enough tokens in the contract\"\n        );\n        \n        // Transfer rewards and original stake\n        bool withdrawSuccess = IERC20(SaleToken).transfer(msg.sender, totalAmount);\n        require(withdrawSuccess, \"Token transfer failed\");\n        \n        emit StakeWithdrawn(msg.sender, stakedAmount, reward, block.timestamp);\n    }\n    \n    /**\n     * @dev Get user staking information\n     * @param _user Address of the user\n     */\n    function getUserStakingInfo(address _user) external view returns (\n        uint256 stakedAmount,\n        uint256 stakingTime,\n        uint256 unlockTime,\n        bool isLocked,\n        bool hasWithdrawn,\n        uint256 potentialReward,\n        uint256 totalClaimable\n    ) {\n        StakeInfo storage stake = userStakes[_user];\n        bool locked = block.timestamp < stake.unlockTimestamp;\n        uint256 reward = stake.stakedAmount * STAKING_APY / PERCENT_DENOMINATOR_INT;\n        \n        return (\n            stake.stakedAmount,\n            stake.stakingTimestamp,\n            stake.unlockTimestamp,\n            locked,\n            stake.hasWithdrawn,\n            reward,\n            stake.hasWithdrawn ? 0 : stake.stakedAmount + reward\n        );\n    }\n    \n    /**\n     * @dev Get staking program statistics\n     */\n    function getStakingStats() external view returns (\n        uint256 _totalStaked,\n        uint256 _stakingCap,\n        uint256 _stakingAPY,\n        bool _isActive,\n        uint256 _maxRewards,\n        uint256 _totalRewardsCommitted,\n        uint256 _remainingRewards\n    ) {\n        return (\n            totalStaked,\n            stakingCap,\n            STAKING_APY,\n            stakingActive,\n            maxStakingRewards(),\n            totalStakingRewardsIssued,\n            maxStakingRewards() - totalStakingRewardsIssued\n        );\n    }\n\n    /**\n     * @dev Quick check if staking is available and capacity info\n     * @return _canStake True if staking is active and cap not reached\n     * @return _remainingCapacity Remaining capacity for staking\n     * @return _percentFilled Percentage of staking capacity filled (0-100)\n     */\n    function getStakingAvailability() external view returns (\n        bool _canStake,\n        uint256 _remainingCapacity,\n        uint256 _percentFilled\n    ) {\n        bool canStake = stakingActive && totalStaked < stakingCap;\n        uint256 remainingCapacity = stakingCap > totalStaked ? stakingCap - totalStaked : 0;\n        uint256 percentFilled = totalStaked * 100 / stakingCap;\n        \n        return (canStake, remainingCapacity, percentFilled);\n    }\n    \n    /**\n     * @dev Update staking cap\n     * @param _newCap New staking cap\n     */\n    function updateStakingCap(uint256 _newCap) external onlyOwner {\n        require(_newCap >= totalStaked, \"New cap must be >= total staked\");\n        \n        uint256 oldCap = stakingCap;\n        stakingCap = _newCap;\n        \n        emit StakingCapUpdated(oldCap, _newCap, block.timestamp);\n    }\n    \n    /**\n     * @dev Safe withdrawal function for accumulated tokens\n     * @param _token Token address\n     * @param _amount Amount to withdraw\n     * @param _recipient Recipient address\n     */\n    function safeWithdraw(address _token, uint256 _amount, address _recipient) external onlyOwner {\n        require(_recipient != address(0), \"Cannot withdraw to zero address\");\n        \n        if (_token == SaleToken) {\n            // Calculate tokens needed for staking rewards\n            uint256 reservedForStaking = totalStaked * (STAKING_APY + 100) / PERCENT_DENOMINATOR_INT;\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(\n                contractBalance - _amount >= reservedForStaking,\n                \"Cannot withdraw tokens reserved for staking rewards\"\n            );\n        }\n        \n        bool withdrawSuccess = IERC20(_token).transfer(_recipient, _amount);\n        require(withdrawSuccess, \"Token transfer failed\");\n    }\n} "
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "contracts/test/TestUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Test USDT Token\n * @notice Simple ERC20 token for testing purposes with 6 decimals like real USDT\n */\ncontract TestUSDT is ERC20, Ownable {\n    uint8 private _decimals;\n\n    /**\n     * @dev Constructor that mints initial supply to the deployer\n     * @param name Token name\n     * @param symbol Token symbol\n     * @param initialSupply Initial token supply to mint\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        _decimals = 6; // USDT uses 6 decimals\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @dev Returns the number of decimals used for token\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Allows owner to mint additional tokens if needed\n     * @param to Address to receive the tokens\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n} "
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Test Token\n * @notice Simple ERC20 token for testing purposes\n */\ncontract TestToken is ERC20, Ownable {\n    uint8 private _decimals;\n\n    /**\n     * @dev Constructor that mints initial supply to the deployer\n     * @param name Token name\n     * @param symbol Token symbol\n     * @param initialSupply Initial token supply to mint\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        _decimals = 18;\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @dev Returns the number of decimals used for token\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Allows owner to mint additional tokens if needed\n     * @param to Address to receive the tokens\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n} "
    },
    "contracts/test/MockAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Mock Chainlink Aggregator\n * @notice Mock implementation of Chainlink's price feed aggregator for local testing\n * @dev Returns a fixed price for ETH/USD\n */\ncontract MockAggregator is Ownable {\n    // Using 8 decimals like Chainlink price feeds\n    int256 private _price = 2000 * 10**8; // $2000 per ETH\n    uint80 private _roundId = 1;\n    uint256 private _timestamp;\n    \n    /**\n     * @dev Constructor initializes with default values\n     */\n    constructor() Ownable(msg.sender) {\n        _timestamp = block.timestamp;\n    }\n    \n    /**\n     * @dev Returns the latest round data (price, etc.)\n     * @return roundId The round ID\n     * @return answer The price (in this case, ETH/USD with 8 decimals)\n     * @return startedAt Timestamp when the round started\n     * @return updatedAt Timestamp of the last update\n     * @return answeredInRound The round in which the answer was computed\n     */\n    function latestRoundData() external view returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        return (_roundId, _price, _timestamp, _timestamp, _roundId);\n    }\n    \n    /**\n     * @dev Owner can update the price for testing different scenarios\n     * @param newPrice The new price to set (with 8 decimals)\n     */\n    function setPrice(int256 newPrice) external onlyOwner {\n        _price = newPrice;\n        _roundId++;\n        _timestamp = block.timestamp;\n    }\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}