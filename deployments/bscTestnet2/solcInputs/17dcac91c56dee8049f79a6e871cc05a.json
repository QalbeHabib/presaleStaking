{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ISaleStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title Sale Interfaces and Common Structures\n * @notice Shared structures for Sale contracts\n */\ninterface ISaleStructs {\n    // Constants\n    function PERCENT_DENOMINATOR() external view returns (uint256);\n    function TOKEN_DECIMALS() external view returns (uint256);\n    \n    // Data Structures\n    struct PresaleInfo {\n        uint256 cap;\n        uint256 price;\n        uint256 sold;\n        uint256 startTime;\n        uint256 endTime;\n        bool ClaimAble;\n        bool isClosed;\n    }\n    \n    struct User {\n        uint256 TotalBoughtTokens;\n        uint256 TotalPaid;\n        uint256 TotalCollectedReferral;\n        uint256 lastClaimTime;\n        address[] referredUsers;\n        address referrer;\n    }\n    \n    struct Presale {\n        uint256 startTime;\n        uint256 endTime;\n        uint256 price;\n        uint256 nextStagePrice;\n        uint256 Sold;\n        uint256 tokensToSell;\n        uint256 UsdtHardcap;\n        uint256 amountRaised;\n        bool Active;\n        bool isEnableClaim;\n    }\n\n    struct ClaimData {\n        uint256 claimAt;\n        uint256 totalAmount;\n        uint256 claimedAmount;\n    }\n\n    struct ReferralData {\n        address referrer;\n        uint256 totalReferralRewards;\n        uint256 claimedReferralRewards;\n        bool hasReferred;\n        uint256 referralCount;\n    }\n    \n    struct StakeInfo {\n        uint256 stakedAmount;\n        uint256 stakingTimestamp;\n        uint256 unlockTimestamp;\n        bool hasWithdrawn;\n    }\n    \n    // Events (common)\n    event PresaleCreated(\n        uint256 indexed _id,\n        uint256 _totalTokens,\n        uint256 _startTime,\n        uint256 _endTime\n    );\n    \n    event TokensBought(\n        address indexed user,\n        uint256 indexed id,\n        address indexed purchaseToken,\n        uint256 tokensBought,\n        uint256 amountPaid,\n        uint256 timestamp\n    );\n    \n    event TokensClaimedWithTimestamp(\n        address indexed user,\n        uint256 indexed id,\n        uint256 amount,\n        uint256 timestamp\n    );\n    \n    event TokensPreFunded(\n        address indexed token, \n        uint256 amount, \n        uint256 timestamp\n    );\n} "
    },
    "contracts/Sale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./StakingManager.sol\";\nimport \"./libraries/SaleUtils.sol\";\nimport \"./interfaces/ISaleStructs.sol\";\n\n/**\n * @title PreSale and Staking Contract\n * @notice This contract handles token presale, referral rewards, and staking functionality\n * @dev All tokens (presale, referral, staking) must be sent to the contract before starting\n *\n * Token Allocation:\n * - 30% for presale (30,000,000,000 tokens)\n * - 5% for referral rewards (5,000,000,000 tokens)\n * - 20% for staking rewards (20,000,000,000 tokens)\n *\n * Total: 55% of total supply must be transferred to this contract\n */\ncontract Sale is StakingManager {\n    // Events\n    event TokensBought(\n        address indexed user,\n        uint256 indexed id,\n        address indexed purchaseToken,\n        uint256 tokensBought,\n        uint256 amountPaid,\n        uint256 timestamp\n    );\n    \n    event TokensClaimedWithTimestamp(\n        address indexed user,\n        uint256 indexed id,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev Constructor sets up the contract parameters\n     * @param _oracle Chainlink oracle for ETH price feed\n     * @param _usdt USDT token address\n     * @param _SaleToken Sale token address\n     * @param _MinTokenTobuy Minimum tokens that can be purchased\n     * @param _totalTokenSupply Total token supply (100,000,000,000)\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) \n      StakingManager(_oracle, _usdt, _SaleToken, _MinTokenTobuy, _totalTokenSupply)\n    {}\n\n    /**\n     * @dev Buy into a presale using USDT with option for immediate staking\n     */\n    function buyWithUSDT(\n        uint256 usdAmount, \n        address referrer, \n        bool shouldStake\n    ) external\n        checkPresaleId(presaleId)\n        checkSaleState(presaleId, usdtToTokens(presaleId, usdAmount))\n        nonReentrant\n        returns (bool)\n    {\n        require(isTokenPreFunded, \"Not pre-funded\");\n        require(!paused[presaleId], \"Presale paused\");\n        require(presale[presaleId].Active, \"Inactive presale\");\n        require(presale[presaleId].amountRaised + usdAmount <= presale[presaleId].UsdtHardcap, \"Hardcap limit\");\n\n        // Handle referral if provided and not zero address\n        if (referrer != address(0)) {\n            require(!SaleUtils.isContract(referrer), \"Contract referrer\");\n            recordReferral(referrer);\n        }\n\n        uint256 tokens = usdtToTokens(presaleId, usdAmount);\n        presale[presaleId].Sold += tokens;\n        presale[presaleId].amountRaised += usdAmount;\n        TotalUSDTRaised += usdAmount; \n\n        if (!isExcludeMinToken[msg.sender]) {\n            require(tokens >= MinTokenTobuy, \"Min amount not met\");\n        }\n\n        uint256 ourAllowance = USDTInterface.allowance(_msgSender(), address(this));\n        require(usdAmount <= ourAllowance, \"Insufficient allowance\");\n        \n        (bool success, ) = address(USDTInterface).call(\n            abi.encodeWithSignature(\n                \"transferFrom(address,address,uint256)\",\n                _msgSender(),\n                fundReceiver,\n                usdAmount\n            )\n        );\n        require(success, \"USDT transfer failed\");\n        \n        // Update users mapping with purchase data\n        _updateUserData(tokens, usdAmount, referrer);\n        \n        // Handle tokens based on staking preference\n        _handleTokensAfterPurchase(tokens, shouldStake);\n        \n        emit TokensBought(\n            _msgSender(),\n            presaleId,\n            address(USDTInterface),\n            tokens,\n            usdAmount,\n            block.timestamp\n        );\n        \n        return true;\n    }\n\n    /**\n     * @dev Buy into a presale using ETH with option for immediate staking\n     */\n    function buyWithEth(\n        address referrer, \n        bool shouldStake\n    ) external\n        payable\n        checkPresaleId(presaleId)\n        checkSaleState(presaleId, ethToTokens(presaleId, msg.value))\n        nonReentrant\n        returns (bool)\n    {\n        require(isTokenPreFunded, \"Not pre-funded\");\n        uint256 usdAmount = (msg.value * getLatestPrice() * USDT_MULTIPLIER) / (ETH_MULTIPLIER * ETH_MULTIPLIER);\n        require(presale[presaleId].amountRaised + usdAmount <= presale[presaleId].UsdtHardcap, \"Hardcap limit\");\n\n        require(!paused[presaleId], \"Presale paused\");\n        require(presale[presaleId].Active, \"Inactive presale\");\n        \n        // Handle referral if provided\n        if (referrer != address(0)) {\n            require(!SaleUtils.isContract(referrer), \"Contract referrer\");\n            recordReferral(referrer);\n        }\n\n        uint256 tokens = usdtToTokens(presaleId, usdAmount);\n        if (!isExcludeMinToken[msg.sender]) {\n            require(tokens >= MinTokenTobuy, \"Min amount not met\");\n        }\n        \n        presale[presaleId].Sold += tokens;\n        presale[presaleId].amountRaised += usdAmount;\n        TotalUSDTRaised += usdAmount;\n\n        // Update user data and handle tokens\n        _updateUserData(tokens, usdAmount, referrer);\n        _handleTokensAfterPurchase(tokens, shouldStake);\n\n        SaleUtils.sendValue(payable(fundReceiver), msg.value);\n        \n        emit TokensBought(\n            _msgSender(),\n            presaleId,\n            address(0),\n            tokens,\n            msg.value,\n            block.timestamp\n        );\n        \n        return true;\n    }\n    \n    /**\n     * @dev Update user data after purchase\n     */\n    function _updateUserData(uint256 tokens, uint256 usdAmount, address referrer) private {\n        users[_msgSender()].TotalBoughtTokens += tokens;\n        users[_msgSender()].TotalPaid += usdAmount;\n        users[_msgSender()].lastClaimTime = block.timestamp;\n        \n        if (referrer != address(0)) {\n            processReferralRewards(_msgSender(), tokens);\n        }\n    }\n    \n    /**\n     * @dev Handle tokens after purchase based on staking preference\n     */\n    function _handleTokensAfterPurchase(uint256 tokens, bool shouldStake) private {\n        if (shouldStake) {\n            _handleTokenStaking(_msgSender(), tokens);\n        } else {\n            if (userClaimData[_msgSender()][presaleId].totalAmount > 0) {\n                userClaimData[_msgSender()][presaleId].totalAmount += tokens;\n            } else {\n                userClaimData[_msgSender()][presaleId] = ISaleStructs.ClaimData(0, tokens, 0);\n            }\n        }\n    }\n    \n    /**\n     * @dev Claim function to handle only non-staked tokens\n     */\n    function claimAmount(uint256 _id)\n        public\n        checkPresaleId(_id)\n        returns (bool)\n    {\n        uint256 amount = claimableAmount(msg.sender, _id);\n        \n        require(amount > 0, \"Nothing to claim\");\n        require(SaleToken != address(0), \"Token not set\");\n        require(amount <= IERC20(SaleToken).balanceOf(address(this)), \"Insufficient funds\");\n        require(presale[_id].isEnableClaim, \"Claiming disabled\");\n\n        userClaimData[msg.sender][_id].claimAt = block.timestamp;\n        userClaimData[msg.sender][_id].claimedAmount += amount;\n        \n        // Process based on staking intent\n        if (userStakingIntent[msg.sender]) {\n            _handleTokenStaking(msg.sender, amount);\n            userStakingIntent[msg.sender] = false;\n        } else {\n            bool success = IERC20(SaleToken).transfer(msg.sender, amount);\n            require(success, \"Transfer failed\");\n        }\n        \n        emit TokensClaimedWithTimestamp(msg.sender, _id, amount, block.timestamp);\n        return true;\n    }\n\n    /**\n     * @dev To claim tokens from multiple presales\n     */\n    function claimMultiple(uint256[] calldata _ids) external returns (bool) {\n        require(_ids.length > 0, \"Empty array\");\n        for (uint256 i; i < _ids.length; i++) {\n            require(claimAmount(_ids[i]), \"Claim failed\");\n        }\n        return true;\n    }\n} "
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/StakingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./ReferralManager.sol\";\n\n/**\n * @title Staking Manager Contract\n * @notice This contract handles token staking functionality\n */\ncontract StakingManager is ReferralManager {\n    \n    // Staking system constants and variables\n    uint256 public constant STAKING_APY = 200; // 200% APY\n    uint256 public totalStaked;\n    uint256 public stakingCap; // Cap at 6,666,666,667 tokens\n    bool public stakingActive;\n    uint256 public totalStakingRewardsIssued;\n    \n    // Staking system mappings\n    mapping(address => ISaleStructs.StakeInfo) public userStakes;\n    \n    // Mapping to track users who want to stake ALL their tokens upon claim\n    mapping(address => bool) public userStakingIntent;\n\n    // New Staking Events\n    event TokensStaked(\n        address indexed user, \n        uint256 amount, \n        uint256 stakingTime, \n        uint256 unlockTime\n    );\n\n    event StakeWithdrawn(\n        address indexed user, \n        uint256 stakedAmount, \n        uint256 rewardAmount, \n        uint256 timestamp\n    );\n\n    event StakingStatusChanged(\n        bool isActive,\n        uint256 timestamp\n    );\n    \n    event StakingCapUpdated(\n        uint256 previousCap,\n        uint256 newCap,\n        uint256 timestamp\n    );\n    \n    // Define custom errors at contract level\n    error StakingInactive();\n    error ZeroAmount();\n    error CapExceeded();\n    error RewardLimitExceeded();\n    error LockedStakeExists();\n    error TransferFailed();\n    \n    /**\n     * @dev Constructor initializes staking parameters\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _saleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) \n        ReferralManager(_oracle, _usdt, _saleToken, _MinTokenTobuy, _totalTokenSupply) \n    {\n        // Initialize staking parameters\n        stakingCap = 6666666667 * 10**18; // 6,666,666,667 tokens\n        stakingActive = true; // Staking is active by default\n    }\n    \n    /**\n     * @dev Override withdraw to account for staking rewards\n     */\n    function WithdrawTokens(address _token, uint256 amount) external override onlyOwner {\n        if (_token == SaleToken) {\n            // Calculate tokens needed for rewards and stakes\n            uint256 reservedTokens = totalReferralRewardsIssued +\n                // Staked tokens plus their potential rewards\n                totalStaked * (STAKING_APY + 100) / 100;\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(contractBalance - amount >= reservedTokens, \"Reserved tokens\");\n        }\n        \n        bool success = IERC20(_token).transfer(fundReceiver, amount);\n        require(success, \"Transfer failed\");\n    }\n    \n    /**\n     * @dev Safe withdrawal function for accumulated tokens\n     * @param _token Token address\n     * @param _amount Amount to withdraw\n     * @param _recipient Recipient address\n     */\n    function safeWithdraw(address _token, uint256 _amount, address _recipient) external onlyOwner {\n        require(_recipient != address(0), \"Zero address\");\n        \n        if (_token == SaleToken) {\n            // Calculate tokens needed for staking rewards\n            uint256 reservedForStaking = totalStaked * (STAKING_APY + 100) / 100;\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(contractBalance - _amount >= reservedForStaking, \"Reserved tokens\");\n        }\n        \n        bool withdrawSuccess = IERC20(_token).transfer(_recipient, _amount);\n        require(withdrawSuccess, \"Transfer failed\");\n    }\n    \n    /**\n     * @dev Toggle staking status (active/inactive)\n     */\n    function setStakingStatus(bool _status) external onlyOwner {\n        stakingActive = _status;\n        emit StakingStatusChanged(_status, block.timestamp);\n    }\n\n    /**\n     * @dev Helper function that handles token staking directly during purchase\n     */\n    function _handleTokenStaking(address _user, uint256 _amount) internal {\n        // Ensure staking is active\n        require(stakingActive, \"Staking inactive\");\n        require(_amount > 0, \"Zero amount\");\n        require(totalStaked + _amount <= stakingCap, \"Cap exceeded\");\n        \n        // Calculate potential rewards to verify we stay within the rewards limit\n        uint256 potentialReward = _amount * STAKING_APY / 100;\n        require(totalStakingRewardsIssued + potentialReward <= maxStakingRewards(), \"Reward limit\");\n        \n        // Update global state for staking\n        totalStaked += _amount;\n        totalStakingRewardsIssued += potentialReward;\n        \n        // Auto-disable staking if cap is reached\n        if (totalStaked >= stakingCap) {\n            stakingActive = false;\n            emit StakingStatusChanged(false, block.timestamp);\n        }\n        \n        // Update user stake\n        ISaleStructs.StakeInfo storage userStake = userStakes[_user];\n        \n        // If user already has a stake, handle appropriately\n        if (userStake.stakedAmount > 0 && !userStake.hasWithdrawn) {\n            // If existing stake is still locked, cannot add to it\n            if (block.timestamp < userStake.unlockTimestamp) {\n                revert LockedStakeExists();\n            } else {\n                // Existing stake is unlocked, withdraw it first\n                _processUnlockedStake(_user, userStake);\n            }\n        }\n        \n        // Create a new stake\n        _createNewStake(_user, _amount, userStake);\n    }\n    \n    /**\n     * @dev Process an unlocked stake by returning principal + rewards\n     */\n    function _processUnlockedStake(address _user, ISaleStructs.StakeInfo storage userStake) private {\n        uint256 stakedAmount = userStake.stakedAmount;\n        uint256 reward = stakedAmount * STAKING_APY / 100;\n        \n        // Mark as withdrawn to prevent double-dipping\n        userStake.hasWithdrawn = true;\n        \n        // Transfer rewards and original stake back\n        bool transferSuccess = IERC20(SaleToken).transfer(_user, stakedAmount + reward);\n        require(transferSuccess, \"Withdrawal failed\");\n        \n        emit StakeWithdrawn(_user, stakedAmount, reward, block.timestamp);\n    }\n    \n    /**\n     * @dev Create a new stake for a user\n     */\n    function _createNewStake(address _user, uint256 _amount, ISaleStructs.StakeInfo storage userStake) internal {\n        userStake.stakedAmount = _amount;\n        userStake.stakingTimestamp = block.timestamp;\n        userStake.unlockTimestamp = block.timestamp + 365 days;\n        userStake.hasWithdrawn = false;\n        \n        emit TokensStaked(_user, _amount, block.timestamp, userStake.unlockTimestamp);\n    }\n\n    /**\n     * @dev Stake tokens with 1-year lock and 200% APY\n     */\n    function stakeTokens(uint256 _amount) external nonReentrant {\n        if (!stakingActive) revert StakingInactive();\n        if (_amount == 0) revert ZeroAmount();\n        if (totalStaked + _amount > stakingCap) revert CapExceeded();\n        \n        // Cache rewards calculation\n        uint256 potentialReward = _amount * STAKING_APY / 100;\n        require(totalStakingRewardsIssued + potentialReward <= maxStakingRewards(), \"Reward limit\");\n        \n        // Update state once\n        totalStaked += _amount;\n        totalStakingRewardsIssued += potentialReward;\n        \n        // Auto-disable staking if cap is reached\n        if (totalStaked >= stakingCap) {\n            stakingActive = false;\n            emit StakingStatusChanged(false, block.timestamp);\n        }\n        \n        // Update user stake\n        ISaleStructs.StakeInfo storage userStake = userStakes[msg.sender];\n        \n        if (userStake.stakedAmount > 0 && !userStake.hasWithdrawn) {\n            require(block.timestamp >= userStake.unlockTimestamp, \"Locked stake\");\n            \n            // Withdraw previous stake first (internally)\n            _processUnlockedStake(msg.sender, userStake);\n        }\n        \n        // Create a new stake\n        _createNewStake(msg.sender, _amount, userStake);\n        \n        // Transfer tokens from user to contract\n        _transferStakedTokens(msg.sender, _amount);\n    }\n    \n    /**\n     * @dev Transfer tokens from user to contract for staking\n     */\n    function _transferStakedTokens(address _user, uint256 _amount) internal {\n        uint256 balanceBefore = IERC20(SaleToken).balanceOf(address(this));\n        bool transferSuccess = IERC20(SaleToken).transferFrom(_user, address(this), _amount);\n        require(transferSuccess, \"Transfer failed\");\n        \n        // Verify tokens were actually received (protection against fee-on-transfer tokens)\n        uint256 balanceAfter = IERC20(SaleToken).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore + _amount, \"Incorrect amount\");\n    }\n    \n    /**\n     * @dev Withdraw staked tokens and rewards after lock period\n     */\n    function withdrawStake() external nonReentrant {\n        ISaleStructs.StakeInfo storage userStake = userStakes[msg.sender];\n        \n        require(userStake.stakedAmount > 0, \"No stake found\");\n        require(!userStake.hasWithdrawn, \"Already withdrawn\");\n        require(block.timestamp >= userStake.unlockTimestamp, \"Still locked\");\n        \n        uint256 stakedAmount = userStake.stakedAmount;\n        uint256 reward = stakedAmount * STAKING_APY / 100;\n        uint256 totalAmount = stakedAmount + reward;\n        \n        // Mark as withdrawn to prevent double-dipping\n        userStake.hasWithdrawn = true;\n        \n        // Update global state\n        totalStaked = totalStaked - stakedAmount;\n        \n        // Verify there are enough tokens in the contract\n        require(totalAmount <= IERC20(SaleToken).balanceOf(address(this)), \"Insufficient funds\");\n        \n        // Transfer rewards and original stake\n        bool withdrawSuccess = IERC20(SaleToken).transfer(msg.sender, totalAmount);\n        require(withdrawSuccess, \"Transfer failed\");\n        \n        emit StakeWithdrawn(msg.sender, stakedAmount, reward, block.timestamp);\n    }\n    \n    /**\n     * @dev Get user staking information\n     */\n    function getUserStakingInfo(address _user) external view returns (\n        uint256 stakedAmount,\n        uint256 stakingTime,\n        uint256 unlockTime,\n        bool isLocked,\n        bool hasWithdrawn,\n        uint256 potentialReward,\n        uint256 totalClaimable\n    ) {\n        ISaleStructs.StakeInfo storage stake = userStakes[_user];\n        bool locked = block.timestamp < stake.unlockTimestamp;\n        uint256 reward = stake.stakedAmount * STAKING_APY / 100;\n        \n        return (\n            stake.stakedAmount,\n            stake.stakingTimestamp,\n            stake.unlockTimestamp,\n            locked,\n            stake.hasWithdrawn,\n            reward,\n            stake.hasWithdrawn ? 0 : stake.stakedAmount + reward\n        );\n    }\n    \n    /**\n     * @dev Get staking program statistics\n     */\n    function getStakingStats() external view returns (\n        uint256 _totalStaked,\n        uint256 _stakingCap,\n        uint256 _stakingAPY,\n        bool _isActive,\n        uint256 _maxRewards,\n        uint256 _totalRewardsCommitted,\n        uint256 _remainingRewards\n    ) {\n        return (\n            totalStaked,\n            stakingCap,\n            STAKING_APY,\n            stakingActive,\n            maxStakingRewards(),\n            totalStakingRewardsIssued,\n            maxStakingRewards() - totalStakingRewardsIssued\n        );\n    }\n\n    /**\n     * @dev Quick check if staking is available and capacity info\n     */\n    function getStakingAvailability() external view returns (\n        bool _canStake,\n        uint256 _remainingCapacity,\n        uint256 _percentFilled\n    ) {\n        bool canStake = stakingActive && totalStaked < stakingCap;\n        uint256 remainingCapacity = stakingCap > totalStaked ? stakingCap - totalStaked : 0;\n        uint256 percentFilled = totalStaked * 100 / stakingCap;\n        \n        return (canStake, remainingCapacity, percentFilled);\n    }\n    \n    /**\n     * @dev Update staking cap\n     */\n    function updateStakingCap(uint256 _newCap) external onlyOwner {\n        require(_newCap >= totalStaked, \"Below total staked\");\n        \n        uint256 oldCap = stakingCap;\n        stakingCap = _newCap;\n        \n        emit StakingCapUpdated(oldCap, _newCap, block.timestamp);\n    }\n    \n    /**\n     * @dev Set staking intent for a user\n     * @param _intent Whether to stake tokens upon claim\n     */\n    function setStakingIntent(bool _intent) external {\n        userStakingIntent[msg.sender] = _intent;\n    }\n \n} "
    },
    "contracts/libraries/SaleUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title Sale Utilities Library\n * @notice Utility functions used across the presale system\n */\nlibrary SaleUtils {\n    /**\n     * @dev Helper to check if an address is a contract\n     * @param _addr Address to check\n     * @return True if the address is a contract\n     */\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /**\n     * @dev Helper function to send ETH safely\n     * @param recipient Address to send ETH to\n     * @param amount Amount of ETH to send\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Low balance\");\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"ETH Payment failed\");\n    }\n} "
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/ReferralManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./SaleBase.sol\";\nimport \"./libraries/SaleUtils.sol\";\n\n/**\n * @title Referral Manager Contract\n * @notice This contract handles token referral functionality\n */\ncontract ReferralManager is SaleBase {\n    // Referral system constants and variables\n    uint256 public constant MINIMUM_PURCHASE_FOR_REFERRAL = 1000 * 10**18; // 1000 tokens minimum to qualify for referral\n    uint8 public referralRewardPercentage = 20; // Default 20% reward (configurable)\n    uint256 public totalReferralRewardsIssued;\n\n    // Anti-gaming time lock for referral changes\n    uint256 public referralPercentageChangeTimeLock;\n\n    // Referral system mappings\n    mapping(address => ISaleStructs.ReferralData) public referralData;\n    mapping(address => bool) public hasQualifiedPurchase; // Track if user has purchased enough to qualify as referrer\n    mapping(address => bool) public hasUsedReferral; // Prevent using multiple referrals\n    mapping(address => mapping(address => bool)) private referredUserExists;\n\n    // Events\n    event ReferralRecorded(address indexed referrer, address indexed referee, uint256 timestamp);\n    event ReferralRewardsClaimed(address indexed user, uint256 amount, uint256 timestamp);\n    event ReferralPercentageUpdated(uint256 previousPercentage, uint256 newPercentage, uint256 timestamp);\n    event ReferralRewardsAdded(address indexed referrer, address indexed referee, uint256 referrerReward, uint256 refereeReward, uint256 timestamp);\n\n    /**\n     * @dev Constructor initializes with same parameters as SaleBase\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) \n        SaleBase(_oracle, _usdt, _SaleToken, _MinTokenTobuy, _totalTokenSupply) \n    {\n        referralPercentageChangeTimeLock = block.timestamp;\n    }\n\n    /**\n     * @dev Override withdraw to account for referral rewards\n     */\n    function WithdrawTokens(address _token, uint256 amount) external virtual override onlyOwner {\n        if (_token == SaleToken) {\n            // Calculate tokens needed for rewards\n            uint256 reservedTokens = totalReferralRewardsIssued;\n            \n            // Check we're not withdrawing reserved tokens\n            uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n            require(contractBalance - amount >= reservedTokens, \"Cannot withdraw tokens reserved for rewards\");\n        }\n        \n        require(IERC20(_token).transfer(fundReceiver, amount), \"Token transfer failed\");\n    }\n\n    /**\n     * @dev Change referral reward percentage with timelock protection\n     * @param _percentage New percentage (1-20)\n     */\n    function updateReferralRewardPercentage(uint8 _percentage) external onlyOwner {\n        require(_percentage > 0 && _percentage <= 20, \"Invalid percentage\");\n        require(block.timestamp >= referralPercentageChangeTimeLock, \"Timelock active\");\n        \n        // Set new timelock for future changes\n        referralPercentageChangeTimeLock = block.timestamp + 24 hours;\n        \n        emit ReferralPercentageUpdated(referralRewardPercentage, _percentage, block.timestamp);\n        referralRewardPercentage = _percentage;\n    }\n\n    /**\n     * @dev Records a valid referral relationship\n     * @param _referrer Address of the referrer\n     */\n    function recordReferral(address _referrer) public {\n        require(_referrer != address(0) && _referrer != msg.sender, \"Invalid referrer\");\n        require(!hasUsedReferral[msg.sender], \"Already referred\");\n        require(hasQualifiedPurchase[_referrer], \"Unqualified referrer\");\n        \n        // Prevent circular referrals\n        require(referralData[_referrer].referrer != msg.sender, \"Circular referral\");\n        \n        // Check for circular chains\n        address currentReferrer = referralData[_referrer].referrer;\n        while (currentReferrer != address(0)) {\n            require(currentReferrer != msg.sender, \"Circular chain\");\n            currentReferrer = referralData[currentReferrer].referrer;\n        }\n        \n        // Record the referral relationship\n        referralData[msg.sender].referrer = _referrer;\n        users[msg.sender].referrer = _referrer;\n        hasUsedReferral[msg.sender] = true;\n        \n        // Update referrer stats\n        ISaleStructs.ReferralData storage refData = referralData[_referrer];\n        refData.hasReferred = true;\n        refData.referralCount++;\n        \n        // Add user to referrer's referredUsers array\n        if (!referredUserExists[_referrer][msg.sender]) {\n            users[_referrer].referredUsers.push(msg.sender);\n            referredUserExists[_referrer][msg.sender] = true;\n        }\n        \n        emit ReferralRecorded(_referrer, msg.sender, block.timestamp);\n    }\n\n    /**\n     * @dev Process referral rewards after a successful purchase\n     * @param _user Address of the user who made a purchase\n     * @param _tokenAmount Amount of tokens purchased\n     */\n    function processReferralRewards(address _user, uint256 _tokenAmount) public {\n        if (_tokenAmount >= MINIMUM_PURCHASE_FOR_REFERRAL) {\n            hasQualifiedPurchase[_user] = true;\n            \n            address referrer = referralData[_user].referrer;\n            if (referrer != address(0)) {\n                // Calculate rewards\n                uint256 referrerReward = _tokenAmount * referralRewardPercentage / 100;\n                uint256 totalNewRewards = referrerReward * 2; // Both get same reward\n                \n                // Update rewards if under max cap\n                if (totalReferralRewardsIssued + totalNewRewards <= maxReferralRewards) {\n                    referralData[referrer].totalReferralRewards += referrerReward;\n                    referralData[_user].totalReferralRewards += referrerReward;\n                    totalReferralRewardsIssued += totalNewRewards;\n                    \n                    emit ReferralRewardsAdded(referrer, _user, referrerReward, referrerReward, block.timestamp);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get claimable referral rewards for a user\n     * @param _user Address of the user\n     */\n    function getClaimableReferralRewards(address _user) public view returns (uint256) {\n        ISaleStructs.ReferralData memory data = referralData[_user];\n        return data.totalReferralRewards - data.claimedReferralRewards;\n    }\n\n    /**\n     * @dev Claim referral rewards\n     */\n    function claimReferralRewards() external nonReentrant returns (bool) {\n        uint256 amount = getClaimableReferralRewards(msg.sender);\n        require(amount > 0, \"No rewards to claim\");\n        \n        // Verify there are enough tokens in the contract\n        require(amount <= IERC20(SaleToken).balanceOf(address(this)), \"Not enough tokens in contract\");\n        \n        // Update claimed amount first to prevent reentrancy\n        referralData[msg.sender].claimedReferralRewards += amount;\n        \n        // Transfer tokens\n        require(IERC20(SaleToken).transfer(msg.sender, amount), \"Token transfer failed\");\n        \n        emit ReferralRewardsClaimed(msg.sender, amount, block.timestamp);\n        return true;\n    }\n\n    /**\n     * @dev Get user referral info for frontend\n     */\n    function getUserReferralInfo(address _user) external view returns (\n        address referrer,\n        uint256 totalRewards,\n        uint256 claimedRewards,\n        uint256 pendingRewards,\n        bool isQualifiedReferrer,\n        uint256 referralCount\n    ) {\n        ISaleStructs.ReferralData memory data = referralData[_user];\n        return (\n            data.referrer,\n            data.totalReferralRewards,\n            data.claimedReferralRewards,\n            data.totalReferralRewards - data.claimedReferralRewards,\n            hasQualifiedPurchase[_user],\n            data.referralCount\n        );\n    }\n\n    /**\n     * @dev Get referral program stats\n     */\n    function getReferralProgramStats() external view returns (\n        uint256 currentPercentage,\n        uint256 totalRewardsIssued,\n        uint256 maxRewards,\n        uint256 remainingRewards,\n        uint256 nextPercentageChangeAllowed\n    ) {\n        return (\n            referralRewardPercentage,\n            totalReferralRewardsIssued,\n            maxReferralRewards,\n            maxReferralRewards - totalReferralRewardsIssued,\n            referralPercentageChangeTimeLock\n        );\n    }\n\n    /**\n     * @dev Update the maximum referral rewards (5% of total supply)\n     * @param _totalSupply The total token supply to calculate 5% from\n     */\n    function updateMaxReferralRewards(uint256 _totalSupply) external onlyOwner {\n        require(_totalSupply > 0, \"Invalid total supply\");\n        maxReferralRewards = _totalSupply * 5 / 100;\n    }\n\n    /**\n     * @dev Check if a user has a valid referral link to share\n     */\n    function canReferOthers(address _user) external view returns (bool) {\n        return hasQualifiedPurchase[_user];\n    }\n\n    /**\n     * @dev Check if a user can be referred by a specific referrer\n     */\n    function canBeReferred(address _referrer, address _referee) external view returns (bool isEligible, uint8 reason) {\n        if (hasUsedReferral[_referee]) return (false, 1); // Already referred\n        if (_referrer == _referee) return (false, 2); // Self-referral\n        if (!hasQualifiedPurchase[_referrer]) return (false, 3); // Unqualified referrer\n        if (referralData[_referrer].referrer == _referee) return (false, 2); // Direct circular referral\n        \n        // Check for circular chain\n        address currentReferrer = referralData[_referrer].referrer;\n        while (currentReferrer != address(0)) {\n            if (currentReferrer == _referee) return (false, 2); // Found in chain\n            currentReferrer = referralData[currentReferrer].referrer;\n        }\n        \n        return (true, 0); // Eligible\n    }\n    \n    /**\n     * @dev Get the entire referral chain for a user\n     */\n    function getReferralChain(address _user) external view returns (address[] memory) {\n        // Count the depth of the referral chain\n        uint256 chainDepth = 0;\n        address current = _user;\n        \n        while (referralData[current].referrer != address(0)) {\n            chainDepth++;\n            current = referralData[current].referrer;\n        }\n        \n        // Create array to hold the chain\n        address[] memory chain = new address[](chainDepth + 1);\n        \n        // Fill the array\n        chain[0] = _user;\n        current = _user;\n        for (uint256 i = 1; i <= chainDepth; i++) {\n            current = referralData[current].referrer;\n            chain[i] = current;\n        }\n        \n        return chain;\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/SaleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"./libraries/SaleUtils.sol\";\nimport \"./interfaces/ISaleStructs.sol\";\n\ninterface Aggregator {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/**\n * @title Sale Base Contract\n */\ncontract SaleBase is ReentrancyGuard, Ownable, Pausable {\n    // State variables\n    address public oracle; // Chainlink oracle address\n    address public usdt; // USDT token address\n    address public SaleToken; // Sale token address\n    uint256 public MinTokenTobuy; // Min tokens to buy\n    uint256 public TotalUSDTRaised; // Total USDT raised\n    uint256 public totalTokenSupply; // Total supply of tokens\n\n    // Presale data\n    uint256 public presaleId;\n    uint256 public USDT_MULTIPLIER;\n    uint256 public ETH_MULTIPLIER;\n    address public fundReceiver;\n    \n    // Total supply and allocations\n    uint256 public presaleTokens;\n    uint256 public maxReferralRewards;\n    uint256 private _maxStakingRewards;\n\n    // Track if the contract has been pre-funded\n    bool public isTokenPreFunded = false;\n\n    IERC20Metadata public USDTInterface;\n    Aggregator internal aggregatorInterface;\n\n    // Main mappings for presale functionality\n    mapping(uint256 => bool) public paused;\n    mapping(uint256 => ISaleStructs.Presale) public presale;\n    mapping(address => mapping(uint256 => ISaleStructs.ClaimData)) public userClaimData;\n    mapping(address => bool) public isExcludeMinToken;\n    mapping(address => bool) public isAdmin;\n    mapping(address => ISaleStructs.User) public users;\n\n    // Events\n    event PresaleStarted(uint256 presaleId, uint256 cap, uint256 price, uint256 startTime, uint256 endTime);\n    event PresaleEnded(uint256 presaleId, uint256 endTime);\n    event PresalePaused(uint256 indexed id, uint256 timestamp);\n    event PresaleUnpaused(uint256 indexed id, uint256 timestamp);\n    event OracleUpdated(address previousOracle, address newOracle, uint256 timestamp);\n    event TokensPreFunded(address indexed token, uint256 amount, uint256 timestamp);\n    event PresaleCreated(uint256 indexed _id, uint256 _totalTokens, uint256 _startTime, uint256 _endTime);\n    \n    /**\n     * @dev Constructor initializes the sale parameters\n     */\n    constructor(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) Ownable(msg.sender) {\n        _initialize(_oracle, _usdt, _SaleToken, _MinTokenTobuy, _totalTokenSupply);\n    }\n    \n    /**\n     * @dev Internal initialization function\n     */\n    function _initialize(\n        address _oracle,\n        address _usdt,\n        address _SaleToken,\n        uint256 _MinTokenTobuy,\n        uint256 _totalTokenSupply\n    ) internal {\n        require(_oracle != address(0), \"Zero oracle\");\n        require(_usdt != address(0), \"Zero USDT\");\n        require(_SaleToken != address(0), \"Zero token\");\n        require(_MinTokenTobuy > 0, \"Zero min\");\n        require(_totalTokenSupply > 0, \"Zero supply\");\n        \n        aggregatorInterface = Aggregator(_oracle);\n        SaleToken = _SaleToken;\n        MinTokenTobuy = _MinTokenTobuy;\n        USDTInterface = IERC20Metadata(_usdt);\n        ETH_MULTIPLIER = (10**18);\n        USDT_MULTIPLIER = (10**6);\n        fundReceiver = msg.sender;\n        \n        // Store total supply\n        totalTokenSupply = _totalTokenSupply;\n        \n        // Calculate allocations - 30% for presale, 5% for referrals, 20% for staking\n        presaleTokens = _totalTokenSupply * 30 / 100;\n        maxReferralRewards = _totalTokenSupply * 5 / 100;\n        _maxStakingRewards = _totalTokenSupply * 20 / 100;\n    }\n    \n    /**\n     * @dev Pre-fund the contract with tokens for presale, referrals, and staking\n     */\n    function preFundContract() external onlyOwner {\n        require(!isTokenPreFunded, \"Already funded\");\n        require(SaleToken != address(0), \"Token not set\");\n        \n        // Calculate total tokens needed\n        uint256 totalRequired = presaleTokens + maxReferralRewards + _maxStakingRewards;\n        \n        // Check contract balance\n        uint256 contractBalance = IERC20(SaleToken).balanceOf(address(this));\n        require(contractBalance >= totalRequired, \"Insufficient balance\");\n        \n        // Set pre-funded flag\n        isTokenPreFunded = true;\n        \n        emit TokensPreFunded(SaleToken, contractBalance, block.timestamp);\n    }\n    \n    /**\n     * @dev Create a new presale\n     */\n    function createPresale(\n        uint256 _price,\n        uint256 _nextStagePrice, \n        uint256 _tokensToSell, \n        uint256 _UsdtHardcap\n    ) external onlyOwner {\n        require(_price > 0, \"Zero price\");\n        require(_tokensToSell > 0, \"Zero tokens\");\n        require(!presale[presaleId].Active, \"Sale active\");\n\n        presaleId++;\n\n        presale[presaleId] = ISaleStructs.Presale(\n            0,\n            0,\n            _price,\n            _nextStagePrice,\n            0,\n            _tokensToSell,\n            _UsdtHardcap,\n            0,\n            false,\n            false\n        );\n\n        emit PresaleCreated(presaleId, _tokensToSell, 0, 0);\n    }\n\n    /**\n     * @dev Start the presale\n     */\n    function startPresale() public onlyOwner {\n        presale[presaleId].startTime = block.timestamp;\n        presale[presaleId].Active = true;\n    }\n\n    /**\n     * @dev End the presale\n     */\n    function endPresale() public onlyOwner {\n        require(presale[presaleId].Active, \"Already inactive\");\n        presale[presaleId].endTime = block.timestamp;\n        presale[presaleId].Active = false;\n    }\n\n    /**\n     * @dev Enable claiming for a presale\n     */\n    function enableClaim(uint256 _id, bool _status)\n        public\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        presale[_id].isEnableClaim = _status;\n    }\n\n    /**\n     * @dev Update presale parameters\n     */\n    function updatePresale(\n        uint256 _id,\n        uint256 _price,\n        uint256 _nextStagePrice,\n        uint256 _tokensToSell,\n        uint256 _Hardcap\n    ) external checkPresaleId(_id) onlyOwner {\n        require(_price > 0, \"Zero price\");\n        require(_tokensToSell > 0, \"Zero tokens\");\n        presale[_id].price = _price;\n        presale[_id].nextStagePrice = _nextStagePrice;\n        presale[_id].tokensToSell = _tokensToSell;\n        presale[_id].UsdtHardcap = _Hardcap;\n    }\n\n    /**\n     * @dev Change fund receiving wallet\n     */\n    function changeFundWallet(address _wallet) external onlyOwner {\n        require(_wallet != address(0), \"Zero address\");\n        fundReceiver = _wallet;\n    }\n\n    /**\n     * @dev Change USDT token address\n     */\n    function changeUSDTToken(address _newAddress) external onlyOwner {\n        require(_newAddress != address(0), \"Zero address\");\n        USDTInterface = IERC20Metadata(_newAddress);\n    }\n\n    /**\n     * @dev Update the sale token address\n     */\n    function ChangeTokentoSell(address _newTokenAddress) external onlyOwner {\n        require(_newTokenAddress != address(0), \"Zero address\");\n        SaleToken = _newTokenAddress;\n    }\n\n    /**\n     * @dev Update minimum token purchase amount\n     */\n    function EditMinTokenToBuy(uint256 _newMinAmount) external onlyOwner {\n        require(_newMinAmount > 0, \"Zero min\");\n        MinTokenTobuy = _newMinAmount;\n    }\n\n    /**\n     * @dev Pause a presale\n     */\n    function pausePresale(uint256 _id) external checkPresaleId(_id) onlyOwner {\n        require(!paused[_id], \"Already paused\");\n        paused[_id] = true;\n        emit PresalePaused(_id, block.timestamp);\n    }\n\n    /**\n     * @dev Unpause a presale\n     */\n    function unPausePresale(uint256 _id)\n        external\n        checkPresaleId(_id)\n        onlyOwner\n    {\n        require(paused[_id], \"Not paused\");\n        paused[_id] = false;\n        emit PresaleUnpaused(_id, block.timestamp);\n    }\n\n    /**\n     * @dev Get the latest ETH price from Chainlink\n     */\n    function getLatestPrice() public view returns (uint256) {\n        (, int256 price, , , ) = aggregatorInterface.latestRoundData();\n        price = (price * (10**10));\n        return uint256(price);\n    }\n\n    /**\n     * @dev Helper funtion to get tokens for eth amount\n     */\n    function ethToTokens(uint256 _id, uint256 amount)\n        public\n        view\n        returns (uint256 _tokens)\n    {\n        uint256 usdAmount = amount * getLatestPrice() * USDT_MULTIPLIER / (ETH_MULTIPLIER * ETH_MULTIPLIER);\n        _tokens = usdtToTokens(_id, usdAmount);\n    }\n\n    /**\n     * @dev Helper funtion to get tokens for given usdt amount\n     */\n    function usdtToTokens(uint256 _id, uint256 amount)\n        public\n        view\n        checkPresaleId(_id)\n        returns (uint256 _tokens)\n    {\n        _tokens = (amount * (10**18)) / presale[_id].price;\n    }\n\n    /**\n     * @dev Helper funtion to get ETH price for given amount\n     */\n    function ethBuyHelper(uint256 _id, uint256 amount)\n        external\n        view\n        checkPresaleId(_id)\n        returns (uint256 ethAmount)\n    {\n        uint256 usdPrice = (amount * presale[_id].price);\n        ethAmount = (usdPrice * ETH_MULTIPLIER) / (getLatestPrice() * 10**IERC20Metadata(SaleToken).decimals());\n    }\n\n    /**\n     * @dev Helper funtion to get USDT price for given amount\n     */\n    function usdtBuyHelper(uint256 _id, uint256 amount)\n        external\n        view\n        checkPresaleId(_id)\n        returns (uint256 usdPrice)\n    {\n        usdPrice = (amount * presale[_id].price) / 10**IERC20Metadata(SaleToken).decimals();\n    }\n\n    /**\n     * @dev Helper funtion to get claimable tokens for a given presale\n     */\n    function claimableAmount(address user, uint256 _id)\n        public\n        view\n        checkPresaleId(_id)\n        returns (uint256)\n    {\n        ISaleStructs.ClaimData memory _user = userClaimData[user][_id];\n\n        require(_user.totalAmount > 0, \"Nothing to claim\");\n        uint256 amount = _user.totalAmount - _user.claimedAmount;\n        require(amount > 0, \"Already claimed\");\n        return amount;\n    }\n\n    /**\n     * @dev Exclude account from minimum buy requirement\n     */\n    function ExcludeAccouctFromMinBuy(address _user, bool _status)\n        external\n        onlyOwner\n    {\n        isExcludeMinToken[_user] = _status;\n    }\n    \n    /**\n     * @dev Public getter for max staking rewards\n     */\n    function maxStakingRewards() public view virtual returns (uint256) {\n        return _maxStakingRewards;\n    }\n\n    /**\n     * @dev Withdraw tokens from contract\n     */\n    function WithdrawTokens(address _token, uint256 amount) external virtual onlyOwner {\n        // Calculate tokens needed for rewards (base implementation only checks referral)\n        uint256 reservedTokens = 0; // To be overridden in inheriting contracts\n        \n        // Check we're not withdrawing reserved tokens\n        uint256 contractBalance = IERC20(_token).balanceOf(address(this));\n        require(contractBalance - amount >= reservedTokens, \"Reserved tokens\");\n        \n        bool success = IERC20(_token).transfer(fundReceiver, amount);\n        require(success, \"Transfer failed\");\n    }\n\n    /**\n     * @dev Withdraw ETH from contract\n     */\n    function WithdrawContractFunds(uint256 amount) external onlyOwner {\n        SaleUtils.sendValue(payable(fundReceiver), amount);\n    }\n\n    /**\n     * @dev Modifier to check presale ID validity\n     */\n    modifier checkPresaleId(uint256 _id) {\n        require(_id > 0 && _id <= presaleId, \"Invalid ID\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check sale state\n     */\n    modifier checkSaleState(uint256 _id, uint256 amount) {\n        require(block.timestamp >= presale[_id].startTime && presale[_id].Active, \"Invalid time\");\n        require(amount > 0 && amount <= presale[_id].tokensToSell-presale[_id].Sold, \"Invalid amount\");\n        _;\n    }\n} "
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "contracts/test/TeatherUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Test USDT Token\n * @notice Simple ERC20 token for testing purposes with 6 decimals like real USDT\n */\ncontract TeatherUSDT is ERC20, Ownable {\n    uint8 private _decimals;\n\n    /**\n     * @dev Constructor that mints initial supply to the deployer\n     * @param name Token name\n     * @param symbol Token symbol\n     * @param initialSupply Initial token supply to mint\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        _decimals = 6; // USDT uses 6 decimals\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @dev Returns the number of decimals used for token\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Allows owner to mint additional tokens if needed\n     * @param to Address to receive the tokens\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n} "
    },
    "contracts/test/PresaleToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Test Token\n * @notice Simple ERC20 token for testing purposes\n */\ncontract PresaleToken is ERC20, Ownable {\n    uint8 private _decimals;\n\n    /**\n     * @dev Constructor that mints initial supply to the deployer\n     * @param name Token name\n     * @param symbol Token symbol\n     * @param initialSupply Initial token supply to mint\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        _decimals = 18; // Default to 6 decimals\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @dev Returns the number of decimals used for token\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Allows owner to mint additional tokens if needed\n     * @param to Address to receive the tokens\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    function setDecimals(uint8 newDecimals) external onlyOwner {\n        _decimals = newDecimals;\n    }\n} "
    },
    "contracts/test/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title ERC20Mock\n * @notice Mock ERC20 token for testing\n */\ncontract ERC20Mock is ERC20 {\n    uint8 private _decimals;\n    \n    /**\n     * @dev Constructor that creates mock token with specified decimals\n     * @param name Token name\n     * @param symbol Token symbol\n     * @param decimalsValue Decimals for the token (e.g., 18 for most tokens, 6 for USDT)\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimalsValue\n    ) ERC20(name, symbol) {\n        _decimals = decimalsValue;\n    }\n    \n    /**\n     * @dev Override decimals function to return custom value\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n    \n    /**\n     * @dev Mint tokens to an address (for testing)\n     * @param to Address to mint tokens to\n     * @param amount Amount of tokens to mint\n     */\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}